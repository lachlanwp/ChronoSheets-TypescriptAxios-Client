// tslint:disable
/**
 * ChronoSheets API
 * <div style=\'font-size: 14px!important;font-family: Open Sans,sans-serif!important;color: #3b4151!important;\'><p>      ChronoSheets is a flexible timesheet solution for small to medium businesses, it is free for small teams of up to 3 and there are iOS and Android apps available.  Use the ChronoSheets API to create your own custom integrations.  Before starting, sign up for a ChronoSheets account at <a target=\'_BLANK\' href=\'http://tsheets.xyz/signup\'>http://tsheets.xyz/signup</a>.  </p></div><div id=\'cs-extra-info\'></div>
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AggregateClient
 */
export interface AggregateClient {
    /**
     * A list of projects that are under this client
     * @type {Array<AggregateProject>}
     * @memberof AggregateClient
     */
    ClientProjects?: Array<AggregateProject>;
    /**
     * The ID of the client
     * @type {number}
     * @memberof AggregateClient
     */
    Id?: number;
    /**
     * The ID of your organisation
     * @type {number}
     * @memberof AggregateClient
     */
    OrganisationId?: number;
    /**
     * The name of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientName?: string;
    /**
     * The address line 1 of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientAddressLine1?: string;
    /**
     * The address line 2 of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientAddressLine2?: string;
    /**
     * The address suburb of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientSuburb?: string;
    /**
     * The address state of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientState?: string;
    /**
     * The postcode of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientPostCode?: string;
    /**
     * The contact person working under the client
     * @type {string}
     * @memberof AggregateClient
     */
    PersonOfContact?: string;
    /**
     * The phone number of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientPhoneNumber?: string;
    /**
     * The mobile phone number of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientMobileNumber?: string;
    /**
     * The email address of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientEmailAddress?: string;
    /**
     * The website URL of the client
     * @type {string}
     * @memberof AggregateClient
     */
    ClientWebURL?: string;
    /**
     * The number of projects under the client
     * @type {number}
     * @memberof AggregateClient
     */
    ProjectCount?: number;
}
/**
 * 
 * @export
 * @interface AggregateJobCode
 */
export interface AggregateJobCode {
    /**
     * The list of available tasks under this job code
     * @type {Array<AggregateJobTask>}
     * @memberof AggregateJobCode
     */
    AvailableTasks?: Array<AggregateJobTask>;
    /**
     * The list of employee IDs that are permitted to record timesheets with this job code (empty means everyone)
     * @type {Array<number>}
     * @memberof AggregateJobCode
     */
    PermittedEmployees?: Array<number>;
    /**
     * The ID of the job code (not the code itself)
     * @type {number}
     * @memberof AggregateJobCode
     */
    Id?: number;
    /**
     * The job code itself
     * @type {string}
     * @memberof AggregateJobCode
     */
    Code?: string;
    /**
     * The name of the client
     * @type {string}
     * @memberof AggregateJobCode
     */
    Client?: string;
    /**
     * The ID of the client
     * @type {number}
     * @memberof AggregateJobCode
     */
    ClientId?: number;
    /**
     * The name of the project
     * @type {string}
     * @memberof AggregateJobCode
     */
    Project?: string;
    /**
     * The ID of the project
     * @type {number}
     * @memberof AggregateJobCode
     */
    ProjectId?: number;
    /**
     * Your organisation ID
     * @type {number}
     * @memberof AggregateJobCode
     */
    OrganisationId?: number;
    /**
     * A flag indicating whether or not the job code has been marked as deleted
     * @type {boolean}
     * @memberof AggregateJobCode
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface AggregateJobTask
 */
export interface AggregateJobTask {
    /**
     * The Id of the task
     * @type {number}
     * @memberof AggregateJobTask
     */
    Id?: number;
    /**
     * The label of the task
     * @type {string}
     * @memberof AggregateJobTask
     */
    Label?: string;
    /**
     * A flag indicating that this task has been marked as deleted
     * @type {boolean}
     * @memberof AggregateJobTask
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface AggregateProject
 */
export interface AggregateProject {
    /**
     * The ID of the project
     * @type {number}
     * @memberof AggregateProject
     */
    Id?: number;
    /**
     * The ID of the client that this project is assigned to
     * @type {number}
     * @memberof AggregateProject
     */
    ClientId?: number;
    /**
     * The ID of your organisation
     * @type {number}
     * @memberof AggregateProject
     */
    OrganisationId?: number;
    /**
     * The name of the project (can be viewed in PROJECT TIMELINES)
     * @type {string}
     * @memberof AggregateProject
     */
    ProjectName?: string;
    /**
     * The estimated cost of the project (can be viewed in PROJECT TIMELINES)
     * @type {number}
     * @memberof AggregateProject
     */
    CostEstimation?: number;
    /**
     * The start date of the project (can be viewed in PROJECT TIMELINES)
     * @type {string}
     * @memberof AggregateProject
     */
    StartDate?: string;
    /**
     * The end date of the project (can be viewed in PROJECT TIMELINES)
     * @type {string}
     * @memberof AggregateProject
     */
    EndDate?: string;
}
/**
 * A standard API response
 * @export
 * @interface ApiResponseBoolean
 */
export interface ApiResponseBoolean {
    /**
     * The main Data of the response
     * @type {boolean}
     * @memberof ApiResponseBoolean
     */
    Data?: boolean;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseBoolean
     */
    Status?: ApiResponseBooleanStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseBoolean
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseBooleanStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseClient
 */
export interface ApiResponseClient {
    /**
     * 
     * @type {Client}
     * @memberof ApiResponseClient
     */
    Data?: Client;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseClient
     */
    Status?: ApiResponseClientStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseClient
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseClientStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseCombinedReportsData
 */
export interface ApiResponseCombinedReportsData {
    /**
     * 
     * @type {CombinedReportsData}
     * @memberof ApiResponseCombinedReportsData
     */
    Data?: CombinedReportsData;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseCombinedReportsData
     */
    Status?: ApiResponseCombinedReportsDataStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseCombinedReportsData
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseCombinedReportsDataStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseDoLoginResponse
 */
export interface ApiResponseDoLoginResponse {
    /**
     * 
     * @type {DoLoginResponse}
     * @memberof ApiResponseDoLoginResponse
     */
    Data?: DoLoginResponse;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseDoLoginResponse
     */
    Status?: ApiResponseDoLoginResponseStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseDoLoginResponse
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseDoLoginResponseStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseFleetVehicle
 */
export interface ApiResponseFleetVehicle {
    /**
     * 
     * @type {FleetVehicle}
     * @memberof ApiResponseFleetVehicle
     */
    Data?: FleetVehicle;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseFleetVehicle
     */
    Status?: ApiResponseFleetVehicleStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseFleetVehicle
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseFleetVehicleStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListExtendedGeofence
 */
export interface ApiResponseForPaginatedListExtendedGeofence {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListExtendedGeofence
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<ExtendedGeofence>}
     * @memberof ApiResponseForPaginatedListExtendedGeofence
     */
    Data?: Array<ExtendedGeofence>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListExtendedGeofence
     */
    Status?: ApiResponseForPaginatedListExtendedGeofenceStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListExtendedGeofence
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListExtendedGeofenceStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListOrgReportTimesheetFileAttachment
 */
export interface ApiResponseForPaginatedListOrgReportTimesheetFileAttachment {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListOrgReportTimesheetFileAttachment
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<OrgReportTimesheetFileAttachment>}
     * @memberof ApiResponseForPaginatedListOrgReportTimesheetFileAttachment
     */
    Data?: Array<OrgReportTimesheetFileAttachment>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTimesheetFileAttachment
     */
    Status?: ApiResponseForPaginatedListOrgReportTimesheetFileAttachmentStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTimesheetFileAttachment
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListOrgReportTimesheetFileAttachmentStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListOrgReportTranscript
 */
export interface ApiResponseForPaginatedListOrgReportTranscript {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListOrgReportTranscript
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<OrgReportTranscript>}
     * @memberof ApiResponseForPaginatedListOrgReportTranscript
     */
    Data?: Array<OrgReportTranscript>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTranscript
     */
    Status?: ApiResponseForPaginatedListOrgReportTranscriptStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTranscript
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListOrgReportTranscriptStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListOrgReportTrip
 */
export interface ApiResponseForPaginatedListOrgReportTrip {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListOrgReportTrip
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<OrgReportTrip>}
     * @memberof ApiResponseForPaginatedListOrgReportTrip
     */
    Data?: Array<OrgReportTrip>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTrip
     */
    Status?: ApiResponseForPaginatedListOrgReportTripStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListOrgReportTrip
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListOrgReportTripStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListRawReportItem
 */
export interface ApiResponseForPaginatedListRawReportItem {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListRawReportItem
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<RawReportItem>}
     * @memberof ApiResponseForPaginatedListRawReportItem
     */
    Data?: Array<RawReportItem>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListRawReportItem
     */
    Status?: ApiResponseForPaginatedListRawReportItemStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListRawReportItem
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListRawReportItemStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence
 */
export interface ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<TimesheetAutomationWithOrgAndGeofence>}
     * @memberof ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence
     */
    Data?: Array<TimesheetAutomationWithOrgAndGeofence>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence
     */
    Status?: ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofenceStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofenceStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListTimesheetFileAttachment
 */
export interface ApiResponseForPaginatedListTimesheetFileAttachment {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListTimesheetFileAttachment
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<TimesheetFileAttachment>}
     * @memberof ApiResponseForPaginatedListTimesheetFileAttachment
     */
    Data?: Array<TimesheetFileAttachment>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTimesheetFileAttachment
     */
    Status?: ApiResponseForPaginatedListTimesheetFileAttachmentStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTimesheetFileAttachment
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListTimesheetFileAttachmentStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A paginated API repsonse
 * @export
 * @interface ApiResponseForPaginatedListTrip
 */
export interface ApiResponseForPaginatedListTrip {
    /**
     * The count of total records that are being paginated
     * @type {number}
     * @memberof ApiResponseForPaginatedListTrip
     */
    TotalSetCount?: number;
    /**
     * The main Data of the response
     * @type {Array<Trip>}
     * @memberof ApiResponseForPaginatedListTrip
     */
    Data?: Array<Trip>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTrip
     */
    Status?: ApiResponseForPaginatedListTripStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseForPaginatedListTrip
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseForPaginatedListTripStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseGeofence
 */
export interface ApiResponseGeofence {
    /**
     * 
     * @type {Geofence}
     * @memberof ApiResponseGeofence
     */
    Data?: Geofence;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseGeofence
     */
    Status?: ApiResponseGeofenceStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseGeofence
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseGeofenceStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseInsertUserResponse
 */
export interface ApiResponseInsertUserResponse {
    /**
     * 
     * @type {InsertUserResponse}
     * @memberof ApiResponseInsertUserResponse
     */
    Data?: InsertUserResponse;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseInsertUserResponse
     */
    Status?: ApiResponseInsertUserResponseStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseInsertUserResponse
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseInsertUserResponseStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseInt32
 */
export interface ApiResponseInt32 {
    /**
     * The main Data of the response
     * @type {number}
     * @memberof ApiResponseInt32
     */
    Data?: number;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseInt32
     */
    Status?: ApiResponseInt32StatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseInt32
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseInt32StatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseJobCode
 */
export interface ApiResponseJobCode {
    /**
     * 
     * @type {JobCode}
     * @memberof ApiResponseJobCode
     */
    Data?: JobCode;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseJobCode
     */
    Status?: ApiResponseJobCodeStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseJobCode
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseJobCodeStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListAggregateClient
 */
export interface ApiResponseListAggregateClient {
    /**
     * The main Data of the response
     * @type {Array<AggregateClient>}
     * @memberof ApiResponseListAggregateClient
     */
    Data?: Array<AggregateClient>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListAggregateClient
     */
    Status?: ApiResponseListAggregateClientStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListAggregateClient
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListAggregateClientStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListAggregateJobCode
 */
export interface ApiResponseListAggregateJobCode {
    /**
     * The main Data of the response
     * @type {Array<AggregateJobCode>}
     * @memberof ApiResponseListAggregateJobCode
     */
    Data?: Array<AggregateJobCode>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListAggregateJobCode
     */
    Status?: ApiResponseListAggregateJobCodeStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListAggregateJobCode
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListAggregateJobCodeStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListClient
 */
export interface ApiResponseListClient {
    /**
     * The main Data of the response
     * @type {Array<Client>}
     * @memberof ApiResponseListClient
     */
    Data?: Array<Client>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListClient
     */
    Status?: ApiResponseListClientStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListClient
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListClientStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListFleetSummaryReportItem
 */
export interface ApiResponseListFleetSummaryReportItem {
    /**
     * The main Data of the response
     * @type {Array<FleetSummaryReportItem>}
     * @memberof ApiResponseListFleetSummaryReportItem
     */
    Data?: Array<FleetSummaryReportItem>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListFleetSummaryReportItem
     */
    Status?: ApiResponseListFleetSummaryReportItemStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListFleetSummaryReportItem
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListFleetSummaryReportItemStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListFleetVehicle
 */
export interface ApiResponseListFleetVehicle {
    /**
     * The main Data of the response
     * @type {Array<FleetVehicle>}
     * @memberof ApiResponseListFleetVehicle
     */
    Data?: Array<FleetVehicle>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListFleetVehicle
     */
    Status?: ApiResponseListFleetVehicleStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListFleetVehicle
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListFleetVehicleStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListInt32
 */
export interface ApiResponseListInt32 {
    /**
     * The main Data of the response
     * @type {Array<number>}
     * @memberof ApiResponseListInt32
     */
    Data?: Array<number>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListInt32
     */
    Status?: ApiResponseListInt32StatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListInt32
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListInt32StatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListJobCode
 */
export interface ApiResponseListJobCode {
    /**
     * The main Data of the response
     * @type {Array<JobCode>}
     * @memberof ApiResponseListJobCode
     */
    Data?: Array<JobCode>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListJobCode
     */
    Status?: ApiResponseListJobCodeStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListJobCode
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListJobCodeStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListJobSeriesReportItem
 */
export interface ApiResponseListJobSeriesReportItem {
    /**
     * The main Data of the response
     * @type {Array<JobSeriesReportItem>}
     * @memberof ApiResponseListJobSeriesReportItem
     */
    Data?: Array<JobSeriesReportItem>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListJobSeriesReportItem
     */
    Status?: ApiResponseListJobSeriesReportItemStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListJobSeriesReportItem
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListJobSeriesReportItemStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListOrganisationGroup
 */
export interface ApiResponseListOrganisationGroup {
    /**
     * The main Data of the response
     * @type {Array<OrganisationGroup>}
     * @memberof ApiResponseListOrganisationGroup
     */
    Data?: Array<OrganisationGroup>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListOrganisationGroup
     */
    Status?: ApiResponseListOrganisationGroupStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListOrganisationGroup
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListOrganisationGroupStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListProject
 */
export interface ApiResponseListProject {
    /**
     * The main Data of the response
     * @type {Array<Project>}
     * @memberof ApiResponseListProject
     */
    Data?: Array<Project>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListProject
     */
    Status?: ApiResponseListProjectStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListProject
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListProjectStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListProjectCostingReportItem
 */
export interface ApiResponseListProjectCostingReportItem {
    /**
     * The main Data of the response
     * @type {Array<ProjectCostingReportItem>}
     * @memberof ApiResponseListProjectCostingReportItem
     */
    Data?: Array<ProjectCostingReportItem>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListProjectCostingReportItem
     */
    Status?: ApiResponseListProjectCostingReportItemStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListProjectCostingReportItem
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListProjectCostingReportItemStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListTimesheet
 */
export interface ApiResponseListTimesheet {
    /**
     * The main Data of the response
     * @type {Array<Timesheet>}
     * @memberof ApiResponseListTimesheet
     */
    Data?: Array<Timesheet>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListTimesheet
     */
    Status?: ApiResponseListTimesheetStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListTimesheet
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListTimesheetStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListTimesheetTask
 */
export interface ApiResponseListTimesheetTask {
    /**
     * The main Data of the response
     * @type {Array<TimesheetTask>}
     * @memberof ApiResponseListTimesheetTask
     */
    Data?: Array<TimesheetTask>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListTimesheetTask
     */
    Status?: ApiResponseListTimesheetTaskStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListTimesheetTask
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListTimesheetTaskStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListUserForManagement
 */
export interface ApiResponseListUserForManagement {
    /**
     * The main Data of the response
     * @type {Array<UserForManagement>}
     * @memberof ApiResponseListUserForManagement
     */
    Data?: Array<UserForManagement>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListUserForManagement
     */
    Status?: ApiResponseListUserForManagementStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListUserForManagement
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListUserForManagementStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListUserHourlyRate
 */
export interface ApiResponseListUserHourlyRate {
    /**
     * The main Data of the response
     * @type {Array<UserHourlyRate>}
     * @memberof ApiResponseListUserHourlyRate
     */
    Data?: Array<UserHourlyRate>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListUserHourlyRate
     */
    Status?: ApiResponseListUserHourlyRateStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListUserHourlyRate
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListUserHourlyRateStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListUserJobFavourite
 */
export interface ApiResponseListUserJobFavourite {
    /**
     * The main Data of the response
     * @type {Array<UserJobFavourite>}
     * @memberof ApiResponseListUserJobFavourite
     */
    Data?: Array<UserJobFavourite>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListUserJobFavourite
     */
    Status?: ApiResponseListUserJobFavouriteStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListUserJobFavourite
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListUserJobFavouriteStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseListUsualHoursDay
 */
export interface ApiResponseListUsualHoursDay {
    /**
     * The main Data of the response
     * @type {Array<UsualHoursDay>}
     * @memberof ApiResponseListUsualHoursDay
     */
    Data?: Array<UsualHoursDay>;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseListUsualHoursDay
     */
    Status?: ApiResponseListUsualHoursDayStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseListUsualHoursDay
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseListUsualHoursDayStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseOrganisation
 */
export interface ApiResponseOrganisation {
    /**
     * 
     * @type {Organisation}
     * @memberof ApiResponseOrganisation
     */
    Data?: Organisation;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseOrganisation
     */
    Status?: ApiResponseOrganisationStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseOrganisation
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseOrganisationStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseOrganisationGroup
 */
export interface ApiResponseOrganisationGroup {
    /**
     * 
     * @type {OrganisationGroup}
     * @memberof ApiResponseOrganisationGroup
     */
    Data?: OrganisationGroup;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseOrganisationGroup
     */
    Status?: ApiResponseOrganisationGroupStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseOrganisationGroup
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseOrganisationGroupStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseProject
 */
export interface ApiResponseProject {
    /**
     * 
     * @type {Project}
     * @memberof ApiResponseProject
     */
    Data?: Project;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseProject
     */
    Status?: ApiResponseProjectStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseProject
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseProjectStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseTimesheetFileAttachment
 */
export interface ApiResponseTimesheetFileAttachment {
    /**
     * 
     * @type {TimesheetFileAttachment}
     * @memberof ApiResponseTimesheetFileAttachment
     */
    Data?: TimesheetFileAttachment;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseTimesheetFileAttachment
     */
    Status?: ApiResponseTimesheetFileAttachmentStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseTimesheetFileAttachment
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseTimesheetFileAttachmentStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseTimesheetTask
 */
export interface ApiResponseTimesheetTask {
    /**
     * 
     * @type {TimesheetTask}
     * @memberof ApiResponseTimesheetTask
     */
    Data?: TimesheetTask;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseTimesheetTask
     */
    Status?: ApiResponseTimesheetTaskStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseTimesheetTask
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseTimesheetTaskStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseTranscription
 */
export interface ApiResponseTranscription {
    /**
     * 
     * @type {Transcription}
     * @memberof ApiResponseTranscription
     */
    Data?: Transcription;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseTranscription
     */
    Status?: ApiResponseTranscriptionStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseTranscription
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseTranscriptionStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseTrip
 */
export interface ApiResponseTrip {
    /**
     * 
     * @type {Trip}
     * @memberof ApiResponseTrip
     */
    Data?: Trip;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseTrip
     */
    Status?: ApiResponseTripStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseTrip
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseTripStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseUpdateOrganisationResponse
 */
export interface ApiResponseUpdateOrganisationResponse {
    /**
     * 
     * @type {UpdateOrganisationResponse}
     * @memberof ApiResponseUpdateOrganisationResponse
     */
    Data?: UpdateOrganisationResponse;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseUpdateOrganisationResponse
     */
    Status?: ApiResponseUpdateOrganisationResponseStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseUpdateOrganisationResponse
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseUpdateOrganisationResponseStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseUpdateProfileResponse
 */
export interface ApiResponseUpdateProfileResponse {
    /**
     * 
     * @type {UpdateProfileResponse}
     * @memberof ApiResponseUpdateProfileResponse
     */
    Data?: UpdateProfileResponse;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseUpdateProfileResponse
     */
    Status?: ApiResponseUpdateProfileResponseStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseUpdateProfileResponse
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseUpdateProfileResponseStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseUpdateUserResponse
 */
export interface ApiResponseUpdateUserResponse {
    /**
     * 
     * @type {UpdateUserResponse}
     * @memberof ApiResponseUpdateUserResponse
     */
    Data?: UpdateUserResponse;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseUpdateUserResponse
     */
    Status?: ApiResponseUpdateUserResponseStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseUpdateUserResponse
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseUpdateUserResponseStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseUserForManagement
 */
export interface ApiResponseUserForManagement {
    /**
     * 
     * @type {UserForManagement}
     * @memberof ApiResponseUserForManagement
     */
    Data?: UserForManagement;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseUserForManagement
     */
    Status?: ApiResponseUserForManagementStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseUserForManagement
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseUserForManagementStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * A standard API response
 * @export
 * @interface ApiResponseUserProfile
 */
export interface ApiResponseUserProfile {
    /**
     * 
     * @type {UserProfile}
     * @memberof ApiResponseUserProfile
     */
    Data?: UserProfile;
    /**
     * The API response status. Indicates if the request was successful, failed or was unauthorised.
     * @type {string}
     * @memberof ApiResponseUserProfile
     */
    Status?: ApiResponseUserProfileStatusEnum;
    /**
     * A message to accompany the response status.  If the Status is failed, this message will hint why it failed and what you need to do.
     * @type {string}
     * @memberof ApiResponseUserProfile
     */
    Message?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiResponseUserProfileStatusEnum {
    Succeeded = 'Succeeded',
    FatalException = 'FatalException',
    GeneralError = 'GeneralError',
    ValidationError = 'ValidationError',
    UnAuthorized = 'UnAuthorized',
    SessionExpired = 'SessionExpired'
}

/**
 * 
 * @export
 * @interface BasicCoordinate
 */
export interface BasicCoordinate {
    /**
     * 
     * @type {number}
     * @memberof BasicCoordinate
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof BasicCoordinate
     */
    Longitude?: number;
}
/**
 * Contains a collection of Timesheet objects that are to be either created or updated.  If the ID of the timesheet is specified in the Timesheet object, then that Timesheet will be updated otherwise it will be created
 * @export
 * @interface BatchUpdateTimesheetRequest
 */
export interface BatchUpdateTimesheetRequest {
    /**
     * A collection of Timesheet objects to be either created or updated
     * @type {Array<Timesheet>}
     * @memberof BatchUpdateTimesheetRequest
     */
    Timesheets?: Array<Timesheet>;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * The ID of the client
     * @type {number}
     * @memberof Client
     */
    Id?: number;
    /**
     * The ID of your organisation
     * @type {number}
     * @memberof Client
     */
    OrganisationId?: number;
    /**
     * The name of the client
     * @type {string}
     * @memberof Client
     */
    ClientName?: string;
    /**
     * The address line 1 of the client
     * @type {string}
     * @memberof Client
     */
    ClientAddressLine1?: string;
    /**
     * The address line 2 of the client
     * @type {string}
     * @memberof Client
     */
    ClientAddressLine2?: string;
    /**
     * The address suburb of the client
     * @type {string}
     * @memberof Client
     */
    ClientSuburb?: string;
    /**
     * The address state of the client
     * @type {string}
     * @memberof Client
     */
    ClientState?: string;
    /**
     * The postcode of the client
     * @type {string}
     * @memberof Client
     */
    ClientPostCode?: string;
    /**
     * The contact person working under the client
     * @type {string}
     * @memberof Client
     */
    PersonOfContact?: string;
    /**
     * The phone number of the client
     * @type {string}
     * @memberof Client
     */
    ClientPhoneNumber?: string;
    /**
     * The mobile phone number of the client
     * @type {string}
     * @memberof Client
     */
    ClientMobileNumber?: string;
    /**
     * The email address of the client
     * @type {string}
     * @memberof Client
     */
    ClientEmailAddress?: string;
    /**
     * The website URL of the client
     * @type {string}
     * @memberof Client
     */
    ClientWebURL?: string;
    /**
     * The number of projects under the client
     * @type {number}
     * @memberof Client
     */
    ProjectCount?: number;
}
/**
 * 
 * @export
 * @interface ClientSeriesReportItem
 */
export interface ClientSeriesReportItem {
    /**
     * 
     * @type {string}
     * @memberof ClientSeriesReportItem
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientSeriesReportItem
     */
    EndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientSeriesReportItem
     */
    ClientId?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientSeriesReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientSeriesReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface ClientSideUser
 */
export interface ClientSideUser {
    /**
     * 
     * @type {number}
     * @memberof ClientSideUser
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientSideUser
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientSideUser
     */
    UserName?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientSideUser
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientSideUser
     */
    LastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientSideUser
     */
    EmailAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientSideUser
     */
    Roles?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientSideUser
     */
    AlertSettings?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideUser
     */
    SetupWizardRequired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideUser
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * 
     * @type {Organisation}
     * @memberof ClientSideUser
     */
    Organisation?: Organisation;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideUser
     */
    IsPrimaryAccount?: boolean;
}
/**
 * 
 * @export
 * @interface ClientTotalsReportItem
 */
export interface ClientTotalsReportItem {
    /**
     * 
     * @type {number}
     * @memberof ClientTotalsReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientTotalsReportItem
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientTotalsReportItem
     */
    ClientId?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientTotalsReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientTotalsReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface CombinedReportsData
 */
export interface CombinedReportsData {
    /**
     * 
     * @type {Array<JobSeriesReportItem>}
     * @memberof CombinedReportsData
     */
    SeriesJobCodes?: Array<JobSeriesReportItem>;
    /**
     * 
     * @type {Array<TaskSeriesReportItem>}
     * @memberof CombinedReportsData
     */
    SeriesTasks?: Array<TaskSeriesReportItem>;
    /**
     * 
     * @type {Array<ClientSeriesReportItem>}
     * @memberof CombinedReportsData
     */
    SeriesClients?: Array<ClientSeriesReportItem>;
    /**
     * 
     * @type {Array<ProjectSeriesReportItem>}
     * @memberof CombinedReportsData
     */
    SeriesProjects?: Array<ProjectSeriesReportItem>;
    /**
     * 
     * @type {Array<JobTotalsReportItem>}
     * @memberof CombinedReportsData
     */
    TotalsJobCodes?: Array<JobTotalsReportItem>;
    /**
     * 
     * @type {Array<TaskTotalsReportItem>}
     * @memberof CombinedReportsData
     */
    TotalsTasks?: Array<TaskTotalsReportItem>;
    /**
     * 
     * @type {Array<ClientTotalsReportItem>}
     * @memberof CombinedReportsData
     */
    TotalsClients?: Array<ClientTotalsReportItem>;
    /**
     * 
     * @type {Array<ProjectTotalsReportItem>}
     * @memberof CombinedReportsData
     */
    TotalsProjects?: Array<ProjectTotalsReportItem>;
}
/**
 * 
 * @export
 * @interface CreateAutomationStepRequest
 */
export interface CreateAutomationStepRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateAutomationStepRequest
     */
    GeofencingId?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAutomationStepRequest
     */
    NfcId?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateAutomationStepRequest
     */
    AutomationActionType?: CreateAutomationStepRequestAutomationActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateAutomationStepRequest
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAutomationStepRequest
     */
    Longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateAutomationStepRequest
     */
    ClientTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateAutomationStepRequestAutomationActionTypeEnum {
    EnterGeofence = 'EnterGeofence',
    ExitGeofence = 'ExitGeofence',
    TapOnNfc = 'TapOnNfc'
}

/**
 * A request object for creating a new geofence
 * @export
 * @interface CreateGeoFenceRequest
 */
export interface CreateGeoFenceRequest {
    /**
     * The name of the geo fence
     * @type {string}
     * @memberof CreateGeoFenceRequest
     */
    Name?: string;
    /**
     * A list of coordinates specifying the geofence region
     * @type {Array<BasicCoordinate>}
     * @memberof CreateGeoFenceRequest
     */
    FenceCoordinates?: Array<BasicCoordinate>;
    /**
     * The job code to be used when the person enters/leaves the geofence
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    TriggerJobCodeId?: number;
    /**
     * The task to be used when the person enters/leaves the geofence
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    TriggerTaskId?: number;
    /**
     * Send an alert to a user, specified by their user ID
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    SendAlertToOrgGroupId?: number;
    /**
     * Define when you want the alerts to be setn
     * @type {string}
     * @memberof CreateGeoFenceRequest
     */
    AlertSettings?: CreateGeoFenceRequestAlertSettingsEnum;
    /**
     * Define how to you want to trigger the timesheet automation
     * @type {string}
     * @memberof CreateGeoFenceRequest
     */
    TriggerSettings?: CreateGeoFenceRequestTriggerSettingsEnum;
    /**
     * The start hour in which this geofence should apply.  After this time, the geofence will be active.
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    StartTimeHour?: number;
    /**
     * The start minute in which this geofence should apply.  After this time, the geofence will be active.
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    StartTimeMinute?: number;
    /**
     * The end hour in which this geofence will stop applying.  After this time, the geofence will be inactive.
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    EndTimeHour?: number;
    /**
     * The end minute in which this geofence will stop applying.  After this time, the geofence will be inactive.
     * @type {number}
     * @memberof CreateGeoFenceRequest
     */
    EndTimeMinute?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateGeoFenceRequestAlertSettingsEnum {
    None = 'None',
    SendWhenEntering = 'SendWhenEntering',
    SendWhenExiting = 'SendWhenExiting',
    SendWhenEnteringOrExiting = 'SendWhenEnteringOrExiting'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateGeoFenceRequestTriggerSettingsEnum {
    None = 'None',
    StartTimesheetWhenEntering = 'StartTimesheetWhenEntering',
    StopTimesheetWhenEntering = 'StopTimesheetWhenEntering',
    StartOnEnterStopOnLeave = 'StartOnEnterStopOnLeave'
}

/**
 * Contains fields for creating a Trip
 * @export
 * @interface CreateTripRequest
 */
export interface CreateTripRequest {
    /**
     * The associated Timesheet record Id.  The Trip will be linked to the Timesheet with this TimesheetId
     * @type {number}
     * @memberof CreateTripRequest
     */
    TimesheetId?: number;
    /**
     * The associated Vehicle Id.  The Trip will show that this Vehicle was used
     * @type {number}
     * @memberof CreateTripRequest
     */
    VehicleId?: number;
    /**
     * A CSV of GPS path co-ordinates.  Format example: -37.8433562,144.7226188;[Lat1],[Long1];........[LatN],[LongN]
     * @type {string}
     * @memberof CreateTripRequest
     */
    PathCoordsStringCsv?: string;
    /**
     * The total distance of the Trip
     * @type {number}
     * @memberof CreateTripRequest
     */
    DistanceMeters?: number;
    /**
     * The Mobile platform that the Trip was recorded on
     * @type {string}
     * @memberof CreateTripRequest
     */
    MobilePlatform?: CreateTripRequestMobilePlatformEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateTripRequestMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}

/**
 * An API Request object for logging into ChronoSheets
 * @export
 * @interface DoLoginRequest
 */
export interface DoLoginRequest {
    /**
     * Your ChronoSheets username or registered email address
     * @type {string}
     * @memberof DoLoginRequest
     */
    UsernameOrEmail?: string;
    /**
     * Your ChronoSheets password
     * @type {string}
     * @memberof DoLoginRequest
     */
    Password?: string;
    /**
     * Increase session expiry beyond default of 1 hour
     * @type {boolean}
     * @memberof DoLoginRequest
     */
    RememberMe?: boolean;
}
/**
 * A Response object containing important information that can be used after the user has logged in
 * @export
 * @interface DoLoginResponse
 */
export interface DoLoginResponse {
    /**
     * The ChronoSheets Auth Token.  Use this token for all subsequent requests to the API.  The Auth Token does these things: holds your session and gives you appropraite authorisation to access API endpoints based on your UserRoles
     * @type {string}
     * @memberof DoLoginResponse
     */
    CSAuthToken?: string;
    /**
     * 
     * @type {ClientSideUser}
     * @memberof DoLoginResponse
     */
    LoggedInUser?: ClientSideUser;
}
/**
 * 
 * @export
 * @interface ExtendedGeofence
 */
export interface ExtendedGeofence {
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    JobCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    TaskName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    CreatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    UpdatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    AlertOrganisation?: string;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    GeoFencingId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    OrgId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    CreatedByUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    LastUpdatedByUserId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    Name?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    LocationName?: string;
    /**
     * 
     * @type {Array<BasicCoordinate>}
     * @memberof ExtendedGeofence
     */
    Coordinates?: Array<BasicCoordinate>;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    CreatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    UpdatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    TriggerJobCodeId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    TriggerTaskId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    TriggerSettings?: ExtendedGeofenceTriggerSettingsEnum;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    AlertToOrgGroupId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtendedGeofence
     */
    AlertSettings?: ExtendedGeofenceAlertSettingsEnum;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    StartTimeHour?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    StartTimeMinute?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    EndTimeHour?: number;
    /**
     * 
     * @type {number}
     * @memberof ExtendedGeofence
     */
    EndTimeMinute?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ExtendedGeofenceTriggerSettingsEnum {
    None = 'None',
    StartTimesheetWhenEntering = 'StartTimesheetWhenEntering',
    StopTimesheetWhenEntering = 'StopTimesheetWhenEntering',
    StartOnEnterStopOnLeave = 'StartOnEnterStopOnLeave'
}
/**
    * @export
    * @enum {string}
    */
export enum ExtendedGeofenceAlertSettingsEnum {
    None = 'None',
    SendWhenEntering = 'SendWhenEntering',
    SendWhenExiting = 'SendWhenExiting',
    SendWhenEnteringOrExiting = 'SendWhenEnteringOrExiting'
}

/**
 * 
 * @export
 * @interface FleetSummaryReportItem
 */
export interface FleetSummaryReportItem {
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    TotalDistanceMetersFiltered?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    TotalDistanceMeters?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    TotalRunningCostDollarsFiltered?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    TotalRunningCostDollars?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof FleetSummaryReportItem
     */
    Name?: string;
    /**
     * 
     * @type {number}
     * @memberof FleetSummaryReportItem
     */
    CostPerKilometer?: number;
    /**
     * 
     * @type {string}
     * @memberof FleetSummaryReportItem
     */
    Make?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetSummaryReportItem
     */
    Model?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetSummaryReportItem
     */
    Year?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetSummaryReportItem
     */
    LicencePlateNumber?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FleetSummaryReportItem
     */
    IsDeleted?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof FleetSummaryReportItem
     */
    PermittedEmployees?: Array<number>;
}
/**
 * 
 * @export
 * @interface FleetVehicle
 */
export interface FleetVehicle {
    /**
     * 
     * @type {number}
     * @memberof FleetVehicle
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof FleetVehicle
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof FleetVehicle
     */
    Name?: string;
    /**
     * 
     * @type {number}
     * @memberof FleetVehicle
     */
    CostPerKilometer?: number;
    /**
     * 
     * @type {string}
     * @memberof FleetVehicle
     */
    Make?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetVehicle
     */
    Model?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetVehicle
     */
    Year?: string;
    /**
     * 
     * @type {string}
     * @memberof FleetVehicle
     */
    LicencePlateNumber?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FleetVehicle
     */
    IsDeleted?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof FleetVehicle
     */
    PermittedEmployees?: Array<number>;
}
/**
 * 
 * @export
 * @interface Geofence
 */
export interface Geofence {
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    GeoFencingId?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    OrgId?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    CreatedByUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    LastUpdatedByUserId?: number;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    Name?: string;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    LocationName?: string;
    /**
     * 
     * @type {Array<BasicCoordinate>}
     * @memberof Geofence
     */
    Coordinates?: Array<BasicCoordinate>;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    CreatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    UpdatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    TriggerJobCodeId?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    TriggerTaskId?: number;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    TriggerSettings?: GeofenceTriggerSettingsEnum;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    AlertToOrgGroupId?: number;
    /**
     * 
     * @type {string}
     * @memberof Geofence
     */
    AlertSettings?: GeofenceAlertSettingsEnum;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    StartTimeHour?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    StartTimeMinute?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    EndTimeHour?: number;
    /**
     * 
     * @type {number}
     * @memberof Geofence
     */
    EndTimeMinute?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GeofenceTriggerSettingsEnum {
    None = 'None',
    StartTimesheetWhenEntering = 'StartTimesheetWhenEntering',
    StopTimesheetWhenEntering = 'StopTimesheetWhenEntering',
    StartOnEnterStopOnLeave = 'StartOnEnterStopOnLeave'
}
/**
    * @export
    * @enum {string}
    */
export enum GeofenceAlertSettingsEnum {
    None = 'None',
    SendWhenEntering = 'SendWhenEntering',
    SendWhenExiting = 'SendWhenExiting',
    SendWhenEnteringOrExiting = 'SendWhenEnteringOrExiting'
}

/**
 * Fields for inserting a new Client
 * @export
 * @interface InsertClientRequest
 */
export interface InsertClientRequest {
    /**
     * The name of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientName?: string;
    /**
     * Address line 1 of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientAddressLine1?: string;
    /**
     * Address line 2 of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientAddressLine2?: string;
    /**
     * The suburb of the Client\'s address
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientSuburb?: string;
    /**
     * The state of the Client\'s address
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientState?: string;
    /**
     * The post code of the Client\'s address
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientPostCode?: string;
    /**
     * The name of the contact working with the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    PersonOfContact?: string;
    /**
     * The phone number of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientPhoneNumber?: string;
    /**
     * The mobile phone number of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientMobileNumber?: string;
    /**
     * The email address of the Client
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientEmailAddress?: string;
    /**
     * The Client\'s website URL
     * @type {string}
     * @memberof InsertClientRequest
     */
    ClientWebURL?: string;
}
/**
 * Fields for inserting a new Job Code
 * @export
 * @interface InsertJobCodeRequest
 */
export interface InsertJobCodeRequest {
    /**
     * A short code for the Job.  This is referred to as a Job Code
     * @type {string}
     * @memberof InsertJobCodeRequest
     */
    Code?: string;
    /**
     * The linked Project.  Time spent with this JobCode is on this Project
     * @type {number}
     * @memberof InsertJobCodeRequest
     */
    ProjectId?: number;
    /**
     * The linked Client.  Time spent with this JobCode is for this Client
     * @type {number}
     * @memberof InsertJobCodeRequest
     */
    ClientId?: number;
    /**
     * A list of Task Ids.  This are the Tasks that become available to the employee when they select this JobCode
     * @type {Array<number>}
     * @memberof InsertJobCodeRequest
     */
    LinkedTaskIds?: Array<number>;
    /**
     * Optionally restrict access to the JobCode by specifying which Organisation Groups can use it
     * @type {Array<number>}
     * @memberof InsertJobCodeRequest
     */
    LinkedOrgGroupIds?: Array<number>;
}
/**
 * Fields for inserting a new Organisation Group
 * @export
 * @interface InsertOrganisationGroupRequest
 */
export interface InsertOrganisationGroupRequest {
    /**
     * The name of the new Organisation Group.  This is used when you\'re looking up Organisation Groups elsewhere through ChronoSheets
     * @type {string}
     * @memberof InsertOrganisationGroupRequest
     */
    OrganisationGroupName?: string;
    /**
     * The Ids of the Users that are going to be in this Organisation Group
     * @type {Array<number>}
     * @memberof InsertOrganisationGroupRequest
     */
    OrganisationGroupUserIds?: Array<number>;
}
/**
 * Fields for inserting a new Project
 * @export
 * @interface InsertProjectRequest
 */
export interface InsertProjectRequest {
    /**
     * The Id of the Client that is associated with the new project
     * @type {number}
     * @memberof InsertProjectRequest
     */
    ClientId?: number;
    /**
     * The name of the new Project
     * @type {string}
     * @memberof InsertProjectRequest
     */
    ProjectName?: string;
    /**
     * The estimated cost of work to complete the project.  This value is used in the Organisation Reports view \'Project Costs\'
     * @type {number}
     * @memberof InsertProjectRequest
     */
    CostEstimation?: number;
    /**
     * The start date of the project.  When the project is due to start
     * @type {string}
     * @memberof InsertProjectRequest
     */
    StartDate?: string;
    /**
     * The end date of the project.  When the project is due to end
     * @type {string}
     * @memberof InsertProjectRequest
     */
    EndDate?: string;
}
/**
 * Fields for inserting a new Task
 * @export
 * @interface InsertTaskRequest
 */
export interface InsertTaskRequest {
    /**
     * The name of the Task.  Used to identify the Task when the user is selecting from a list of available Tasks
     * @type {string}
     * @memberof InsertTaskRequest
     */
    TaskName?: string;
    /**
     * Whether or not GPS Trip Tracking is enabled on this Task.  GPS Trip tracking is available on the iOS and Android apps.  If it\'s enabled an additional dialog is shown to the user after Task selection that allows the User to choose if they want to record the GPS data
     * @type {boolean}
     * @memberof InsertTaskRequest
     */
    TripEnabled?: boolean;
}
/**
 * Fields for inserting a new set of Pay Rates for a user.  Archiving of the previous Pay Rate is done for you automatically
 * @export
 * @interface InsertUserHourlyRateRequest
 */
export interface InsertUserHourlyRateRequest {
    /**
     * The Id of the User that is getting the new set of Pay Rates
     * @type {number}
     * @memberof InsertUserHourlyRateRequest
     */
    UserId?: number;
    /**
     * The Hourly Rate the employee should receive during their usual rostered hours
     * @type {number}
     * @memberof InsertUserHourlyRateRequest
     */
    HourlyRate?: number;
    /**
     * The Hourly Rate the employee should receive during outside of their usual rostered hours
     * @type {number}
     * @memberof InsertUserHourlyRateRequest
     */
    HourlyOvertimeRate?: number;
    /**
     * The current date time
     * @type {string}
     * @memberof InsertUserHourlyRateRequest
     */
    CurrentDate?: string;
}
/**
 * Used to mark a JobCode as a Favourite.  Favourites can be used in the Mobile app and on the ChronoSheets website
 * @export
 * @interface InsertUserJobFavouriteRequest
 */
export interface InsertUserJobFavouriteRequest {
    /**
     * The Id of the JobCode that is being marked as a favourite
     * @type {number}
     * @memberof InsertUserJobFavouriteRequest
     */
    JobId?: number;
}
/**
 * Fields for Inserting a new User account (employee) under your Organisation in ChronoSheets
 * @export
 * @interface InsertUserRequest
 */
export interface InsertUserRequest {
    /**
     * The Email Address of the employee
     * @type {string}
     * @memberof InsertUserRequest
     */
    EmailAddress?: string;
    /**
     * The First Name of the employee
     * @type {string}
     * @memberof InsertUserRequest
     */
    FirstName?: string;
    /**
     * The Last Name of the employee
     * @type {string}
     * @memberof InsertUserRequest
     */
    LastName?: string;
    /**
     * Whether or not the employee is subscribed to ChronoSheets newsletters
     * @type {boolean}
     * @memberof InsertUserRequest
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * A BIT field designating which Roles/Permissions the employee will have when they sign in.  See the {timesheets.types.Enums.UserRoles} Enum for more details
     * @type {number}
     * @memberof InsertUserRequest
     */
    Roles?: number;
    /**
     * A BIT field designating which Alerts the employee will receive.  See the {timesheets.types.Enums.AlertSettings} Enum for more details
     * @type {number}
     * @memberof InsertUserRequest
     */
    AlertSettings?: number;
    /**
     * The UserName of the employee.  This can be used when logging into ChronoSheets
     * @type {string}
     * @memberof InsertUserRequest
     */
    UserName?: string;
    /**
     * Set the starting usual Hourly Pay Rate with this value.  This is the Pay Rate the employee receives for working during Rostered Hours
     * @type {number}
     * @memberof InsertUserRequest
     */
    HourlyPayRate?: number;
    /**
     * Set the starting usual Overtime Hourly Pay Rate with this value.  This is the Pay Rate the employee receives for working outside of Rostered Hours
     * @type {number}
     * @memberof InsertUserRequest
     */
    HourlyOvertimePayRate?: number;
    /**
     * The Current date time
     * @type {string}
     * @memberof InsertUserRequest
     */
    CurrentDate?: string;
}
/**
 * 
 * @export
 * @interface InsertUserResponse
 */
export interface InsertUserResponse {
    /**
     * 
     * @type {number}
     * @memberof InsertUserResponse
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof InsertUserResponse
     */
    UserId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InsertUserResponse
     */
    ValidationErrors?: Array<string>;
}
/**
 * Fields for inserting a new Vehicle
 * @export
 * @interface InsertVehicleRequest
 */
export interface InsertVehicleRequest {
    /**
     * The Name of the Vehicle
     * @type {string}
     * @memberof InsertVehicleRequest
     */
    Name?: string;
    /**
     * The fuel cost / running cost of the Vehicle, measured per kilometer
     * @type {number}
     * @memberof InsertVehicleRequest
     */
    CostPerKilometer?: number;
    /**
     * The make of the Vehicle
     * @type {string}
     * @memberof InsertVehicleRequest
     */
    Make?: string;
    /**
     * The model of the Vehicle
     * @type {string}
     * @memberof InsertVehicleRequest
     */
    Model?: string;
    /**
     * The year the Vehicle was made
     * @type {string}
     * @memberof InsertVehicleRequest
     */
    Year?: string;
    /**
     * The Licence Plate Number of the Vehicle
     * @type {string}
     * @memberof InsertVehicleRequest
     */
    LicencePlateNumber?: string;
    /**
     * Optionally restrict this Vehicle to only be available to employees within these Organisation Groups
     * @type {Array<number>}
     * @memberof InsertVehicleRequest
     */
    LinkedOrgGroupIds?: Array<number>;
}
/**
 * 
 * @export
 * @interface JobCode
 */
export interface JobCode {
    /**
     * The ID of the job code (not the code itself)
     * @type {number}
     * @memberof JobCode
     */
    Id?: number;
    /**
     * The job code itself
     * @type {string}
     * @memberof JobCode
     */
    Code?: string;
    /**
     * The name of the client
     * @type {string}
     * @memberof JobCode
     */
    Client?: string;
    /**
     * The ID of the client
     * @type {number}
     * @memberof JobCode
     */
    ClientId?: number;
    /**
     * The name of the project
     * @type {string}
     * @memberof JobCode
     */
    Project?: string;
    /**
     * The ID of the project
     * @type {number}
     * @memberof JobCode
     */
    ProjectId?: number;
    /**
     * Your organisation ID
     * @type {number}
     * @memberof JobCode
     */
    OrganisationId?: number;
    /**
     * A flag indicating whether or not the job code has been marked as deleted
     * @type {boolean}
     * @memberof JobCode
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface JobSeriesReportItem
 */
export interface JobSeriesReportItem {
    /**
     * 
     * @type {string}
     * @memberof JobSeriesReportItem
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof JobSeriesReportItem
     */
    EndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof JobSeriesReportItem
     */
    JobId?: number;
    /**
     * 
     * @type {number}
     * @memberof JobSeriesReportItem
     */
    ClientId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSeriesReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {number}
     * @memberof JobSeriesReportItem
     */
    ProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSeriesReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof JobSeriesReportItem
     */
    SpanSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSeriesReportItem
     */
    JobCode?: string;
}
/**
 * 
 * @export
 * @interface JobTotalsReportItem
 */
export interface JobTotalsReportItem {
    /**
     * 
     * @type {number}
     * @memberof JobTotalsReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof JobTotalsReportItem
     */
    JobId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobTotalsReportItem
     */
    JobCode?: string;
    /**
     * 
     * @type {number}
     * @memberof JobTotalsReportItem
     */
    ClientId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobTotalsReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {number}
     * @memberof JobTotalsReportItem
     */
    ProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobTotalsReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof JobTotalsReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface OrgReportTimesheetFileAttachment
 */
export interface OrgReportTimesheetFileAttachment {
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    Username?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    LastName?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    TimesheetId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    DocumentS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageLargeS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageMediumS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageSmallS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    TimesheetStart?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    TimesheetEnd?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    FileAttachmentId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    MobilePlatform?: OrgReportTimesheetFileAttachmentMobilePlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    AttachmentType?: OrgReportTimesheetFileAttachmentAttachmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    Notes?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    NonImageFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageLargeFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageMediumFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    ImageSmallFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    OriginalFileName?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    Longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    DateUploaded?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTimesheetFileAttachment
     */
    DateImageCaptured?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    StorageAllocationBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTimesheetFileAttachment
     */
    AudioDurationSeconds?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgReportTimesheetFileAttachmentMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}
/**
    * @export
    * @enum {string}
    */
export enum OrgReportTimesheetFileAttachmentAttachmentTypeEnum {
    Image = 'Image',
    WordDoc = 'WordDoc',
    Pdf = 'Pdf',
    MSSpreadSheet = 'MSSpreadSheet',
    MSPowerPoint = 'MSPowerPoint',
    RichTextFormat = 'RichTextFormat',
    ZipFile = 'ZipFile',
    Other = 'Other',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface OrgReportTranscript
 */
export interface OrgReportTranscript {
    /**
     * 
     * @type {boolean}
     * @memberof OrgReportTranscript
     */
    FinishedJob?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    CompletedProcessing?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    Created?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    StartedProcessing?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    TranscriptionId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    JobName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    Contents?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    MediaType?: OrgReportTranscriptMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    TranscriptionStatus?: OrgReportTranscriptTranscriptionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    Username?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    LastName?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    TimesheetId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    DocumentS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageLargeS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageMediumS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageSmallS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    TimesheetStart?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    TimesheetEnd?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    FileAttachmentId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    MobilePlatform?: OrgReportTranscriptMobilePlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    AttachmentType?: OrgReportTranscriptAttachmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    Notes?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    NonImageFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageLargeFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageMediumFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    ImageSmallFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    OriginalFileName?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    Longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    DateUploaded?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTranscript
     */
    DateImageCaptured?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    StorageAllocationBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTranscript
     */
    AudioDurationSeconds?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgReportTranscriptMediaTypeEnum {
    Other = 'Other',
    Mp3 = 'Mp3',
    Mp4 = 'Mp4',
    Wav = 'Wav',
    Flac = 'Flac'
}
/**
    * @export
    * @enum {string}
    */
export enum OrgReportTranscriptTranscriptionStatusEnum {
    Saved = 'Saved',
    Processing = 'Processing',
    Completed = 'Completed',
    FailedWithError = 'FailedWithError'
}
/**
    * @export
    * @enum {string}
    */
export enum OrgReportTranscriptMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}
/**
    * @export
    * @enum {string}
    */
export enum OrgReportTranscriptAttachmentTypeEnum {
    Image = 'Image',
    WordDoc = 'WordDoc',
    Pdf = 'Pdf',
    MSSpreadSheet = 'MSSpreadSheet',
    MSPowerPoint = 'MSPowerPoint',
    RichTextFormat = 'RichTextFormat',
    ZipFile = 'ZipFile',
    Other = 'Other',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface OrgReportTrip
 */
export interface OrgReportTrip {
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    Username?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    LastName?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    TripId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    TimesheetId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    VehicleId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    MobilePlatform?: OrgReportTripMobilePlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    EndDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    VehicleName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    VehicleMake?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    VehicleModel?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    VehicleYear?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    CostPerKilometer?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    TripTotalCost?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgReportTrip
     */
    TotalTripDistanceMeters?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    StartAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    EndAddress?: string;
    /**
     * 
     * @type {Array<TripCoordinate>}
     * @memberof OrgReportTrip
     */
    PathCoordinates?: Array<TripCoordinate>;
    /**
     * 
     * @type {string}
     * @memberof OrgReportTrip
     */
    CacheExpiryDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgReportTripMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {number}
     * @memberof Organisation
     */
    Id?: number;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    AddressLine01?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    AddressLine02?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Suburb?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    State?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Postcode?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Country?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    Timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SubscriptionCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SignupToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Organisation
     */
    IsActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    StripeCouponCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SubscriptionSource?: OrganisationSubscriptionSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SignUpSource?: OrganisationSignUpSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    MobileSignUpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SubscriptionCycleStart?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    SubscriptionCycleEnd?: string;
    /**
     * 
     * @type {Array<OrganisationPricingPlan>}
     * @memberof Organisation
     */
    PricingPlans?: Array<OrganisationPricingPlan>;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganisationSubscriptionSourceEnum {
    None = 'None',
    Stripe = 'Stripe',
    AppleInApp = 'AppleInApp',
    GoogleInApp = 'GoogleInApp'
}
/**
    * @export
    * @enum {string}
    */
export enum OrganisationSignUpSourceEnum {
    Desktop = 'Desktop',
    MobileiOS = 'MobileiOS',
    MobileAndroid = 'MobileAndroid'
}

/**
 * 
 * @export
 * @interface OrganisationGroup
 */
export interface OrganisationGroup {
    /**
     * 
     * @type {number}
     * @memberof OrganisationGroup
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganisationGroup
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganisationGroup
     */
    OrganisationGroupName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganisationGroup
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface OrganisationPricingPlan
 */
export interface OrganisationPricingPlan {
    /**
     * 
     * @type {string}
     * @memberof OrganisationPricingPlan
     */
    PlanId?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganisationPricingPlan
     */
    Quantity?: number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    ClientId?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    CostEstimation?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    CostActual?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    EndDate?: string;
}
/**
 * 
 * @export
 * @interface ProjectCostingReportItem
 */
export interface ProjectCostingReportItem {
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    ProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectCostingReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    ClientId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectCostingReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    EstimatedCost?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    ActualCostFiltered?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectCostingReportItem
     */
    ActualCost?: number;
}
/**
 * 
 * @export
 * @interface ProjectSeriesReportItem
 */
export interface ProjectSeriesReportItem {
    /**
     * 
     * @type {string}
     * @memberof ProjectSeriesReportItem
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSeriesReportItem
     */
    EndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectSeriesReportItem
     */
    ProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectSeriesReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectSeriesReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface ProjectTotalsReportItem
 */
export interface ProjectTotalsReportItem {
    /**
     * 
     * @type {number}
     * @memberof ProjectTotalsReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTotalsReportItem
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTotalsReportItem
     */
    ProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectTotalsReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectTotalsReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface RawReportItem
 */
export interface RawReportItem {
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    UserId?: number;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    Username?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    JobCode?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    TaskName?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    ClientName?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    ProjectName?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    EndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    SpanSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof RawReportItem
     */
    Description?: string;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    PayAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    PayOvertimeAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    TripCost?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    TripDistanceMeters?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    SpanSecondsNormalTime?: number;
    /**
     * 
     * @type {number}
     * @memberof RawReportItem
     */
    SpanSecondsOvertime?: number;
}
/**
 * Fields used to save a Client
 * @export
 * @interface SaveClientRequest
 */
export interface SaveClientRequest {
    /**
     * The Id of the Client
     * @type {number}
     * @memberof SaveClientRequest
     */
    Id?: number;
    /**
     * The name of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientName?: string;
    /**
     * Address line 1 of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientAddressLine1?: string;
    /**
     * Address line 2 of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientAddressLine2?: string;
    /**
     * The suburb of the Client\'s address
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientSuburb?: string;
    /**
     * The state of the Client\'s address
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientState?: string;
    /**
     * The post code of the Client\'s address
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientPostCode?: string;
    /**
     * The name of the contact working with the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    PersonOfContact?: string;
    /**
     * The phone number of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientPhoneNumber?: string;
    /**
     * The mobile phone number of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientMobileNumber?: string;
    /**
     * The email address of the Client
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientEmailAddress?: string;
    /**
     * The Client\'s website URL
     * @type {string}
     * @memberof SaveClientRequest
     */
    ClientWebURL?: string;
}
/**
 * Fields used to save an OrganisationGroup
 * @export
 * @interface SaveOrganisationGroupRequest
 */
export interface SaveOrganisationGroupRequest {
    /**
     * The Id of the Organisation Group you want to update/save
     * @type {number}
     * @memberof SaveOrganisationGroupRequest
     */
    Id?: number;
    /**
     * The updated name of the Organisation Group
     * @type {string}
     * @memberof SaveOrganisationGroupRequest
     */
    OrganisationGroupName?: string;
    /**
     * Whether or not the Organisation Group is to be marked as deleted
     * @type {boolean}
     * @memberof SaveOrganisationGroupRequest
     */
    IsDeleted?: boolean;
}
/**
 * Fields for saving an existing Vehicle
 * @export
 * @interface SaveVehicleRequest
 */
export interface SaveVehicleRequest {
    /**
     * The Id of the Vehicle that is being updated
     * @type {number}
     * @memberof SaveVehicleRequest
     */
    Id?: number;
    /**
     * The Name of the Vehicle
     * @type {string}
     * @memberof SaveVehicleRequest
     */
    Name?: string;
    /**
     * The fuel cost / running cost of the Vehicle, measured per kilometer
     * @type {number}
     * @memberof SaveVehicleRequest
     */
    CostPerKilometer?: number;
    /**
     * The make of the Vehicle
     * @type {string}
     * @memberof SaveVehicleRequest
     */
    Make?: string;
    /**
     * The model of the Vehicle
     * @type {string}
     * @memberof SaveVehicleRequest
     */
    Model?: string;
    /**
     * The year the Vehicle was made
     * @type {string}
     * @memberof SaveVehicleRequest
     */
    Year?: string;
    /**
     * The Licence Plate Number of the Vehicle
     * @type {string}
     * @memberof SaveVehicleRequest
     */
    LicencePlateNumber?: string;
    /**
     * Optionally restrict this Vehicle to only be available to employees within these Organisation Groups
     * @type {Array<number>}
     * @memberof SaveVehicleRequest
     */
    LinkedOrgGroupIds?: Array<number>;
    /**
     * Whether or not this Vehicle is to be marked as deleted
     * @type {boolean}
     * @memberof SaveVehicleRequest
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface SetOrganisationGroupUsersRequest
 */
export interface SetOrganisationGroupUsersRequest {
    /**
     * 
     * @type {number}
     * @memberof SetOrganisationGroupUsersRequest
     */
    OrganisationGroupId?: number;
    /**
     * 
     * @type {string}
     * @memberof SetOrganisationGroupUsersRequest
     */
    CsvUserIds?: string;
}
/**
 * An object that can be used to set the Usual Hours (Rostered Hours) of an employee user account
 * @export
 * @interface SetUsualHoursRequest
 */
export interface SetUsualHoursRequest {
    /**
     * A Collection of days (Mon-Sun) with updated Roster timeslots
     * @type {Array<UsualHoursDay>}
     * @memberof SetUsualHoursRequest
     */
    UsualHoursData?: Array<UsualHoursDay>;
    /**
     * The Id of the User that these updated Rostered Hours will be applied to
     * @type {number}
     * @memberof SetUsualHoursRequest
     */
    UserId?: number;
}
/**
 * 
 * @export
 * @interface TaskSeriesReportItem
 */
export interface TaskSeriesReportItem {
    /**
     * 
     * @type {string}
     * @memberof TaskSeriesReportItem
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSeriesReportItem
     */
    EndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskSeriesReportItem
     */
    TaskId?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskSeriesReportItem
     */
    TaskName?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskSeriesReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface TaskTotalsReportItem
 */
export interface TaskTotalsReportItem {
    /**
     * 
     * @type {number}
     * @memberof TaskTotalsReportItem
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskTotalsReportItem
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskTotalsReportItem
     */
    TaskId?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskTotalsReportItem
     */
    TaskName?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskTotalsReportItem
     */
    SpanSeconds?: number;
}
/**
 * 
 * @export
 * @interface TimeSlot
 */
export interface TimeSlot {
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    DayType?: TimeSlotDayTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    UsualHourId?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    StartHour?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    StartMinute?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    EndHour?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    EndMinute?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSlot
     */
    IsValid?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeSlotDayTypeEnum {
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday',
    Sunday = 'Sunday'
}

/**
 * 
 * @export
 * @interface Timesheet
 */
export interface Timesheet {
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    TimesheetId?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    JobId?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    TaskId?: number;
    /**
     * 
     * @type {string}
     * @memberof Timesheet
     */
    StartDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheet
     */
    EndDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheet
     */
    Description?: string;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    TripId?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    FileAttachmentCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    PayAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Timesheet
     */
    OvertimePayAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Timesheet
     */
    IncludesOvertime?: boolean;
}
/**
 * 
 * @export
 * @interface TimesheetAutomationWithOrgAndGeofence
 */
export interface TimesheetAutomationWithOrgAndGeofence {
    /**
     * 
     * @type {number}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    GeofenceName?: string;
    /**
     * 
     * @type {Array<BasicCoordinate>}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    Coordinates?: Array<BasicCoordinate>;
    /**
     * 
     * @type {number}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    UserId?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    UserName?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    LastName?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    AutomationId?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    AutomationActionType?: TimesheetAutomationWithOrgAndGeofenceAutomationActionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    Created?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    Longitude?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    IsProcessed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    Expires?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetAutomationWithOrgAndGeofence
     */
    ClientDateTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TimesheetAutomationWithOrgAndGeofenceAutomationActionTypeEnum {
    EnterGeofence = 'EnterGeofence',
    ExitGeofence = 'ExitGeofence',
    TapOnNfc = 'TapOnNfc'
}

/**
 * 
 * @export
 * @interface TimesheetFileAttachment
 */
export interface TimesheetFileAttachment {
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    TimesheetId?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    DocumentS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageLargeS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageMediumS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageSmallS3SignedUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    TimesheetStart?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    TimesheetEnd?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    FileAttachmentId?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    MobilePlatform?: TimesheetFileAttachmentMobilePlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    AttachmentType?: TimesheetFileAttachmentAttachmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    Notes?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    NonImageFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageLargeFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageMediumFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    ImageSmallFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    OriginalFileName?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    Longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    DateUploaded?: string;
    /**
     * 
     * @type {string}
     * @memberof TimesheetFileAttachment
     */
    DateImageCaptured?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    StorageAllocationBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetFileAttachment
     */
    AudioDurationSeconds?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum TimesheetFileAttachmentMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}
/**
    * @export
    * @enum {string}
    */
export enum TimesheetFileAttachmentAttachmentTypeEnum {
    Image = 'Image',
    WordDoc = 'WordDoc',
    Pdf = 'Pdf',
    MSSpreadSheet = 'MSSpreadSheet',
    MSPowerPoint = 'MSPowerPoint',
    RichTextFormat = 'RichTextFormat',
    ZipFile = 'ZipFile',
    Other = 'Other',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface TimesheetTask
 */
export interface TimesheetTask {
    /**
     * 
     * @type {number}
     * @memberof TimesheetTask
     */
    Id?: number;
    /**
     * 
     * @type {string}
     * @memberof TimesheetTask
     */
    TaskName?: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetTask
     */
    OrganisationId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimesheetTask
     */
    IsDeleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimesheetTask
     */
    TripEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface Transcription
 */
export interface Transcription {
    /**
     * 
     * @type {number}
     * @memberof Transcription
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcription
     */
    OrgId?: number;
    /**
     * 
     * @type {number}
     * @memberof Transcription
     */
    FileAttachmentId?: number;
    /**
     * 
     * @type {string}
     * @memberof Transcription
     */
    Created?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcription
     */
    Status?: TranscriptionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transcription
     */
    MediaType?: TranscriptionMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transcription
     */
    Contents?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TranscriptionStatusEnum {
    Saved = 'Saved',
    Processing = 'Processing',
    Completed = 'Completed',
    FailedWithError = 'FailedWithError'
}
/**
    * @export
    * @enum {string}
    */
export enum TranscriptionMediaTypeEnum {
    Other = 'Other',
    Mp3 = 'Mp3',
    Mp4 = 'Mp4',
    Wav = 'Wav',
    Flac = 'Flac'
}

/**
 * 
 * @export
 * @interface Trip
 */
export interface Trip {
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    TripId?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    TimesheetId?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    VehicleId?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    OrgId?: number;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    MobilePlatform?: TripMobilePlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    EndDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    VehicleName?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    VehicleMake?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    VehicleModel?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    VehicleYear?: string;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    CostPerKilometer?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    TripTotalCost?: number;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    TotalTripDistanceMeters?: number;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    StartAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    EndAddress?: string;
    /**
     * 
     * @type {Array<TripCoordinate>}
     * @memberof Trip
     */
    PathCoordinates?: Array<TripCoordinate>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    CacheExpiryDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TripMobilePlatformEnum {
    Unknown = 'Unknown',
    IOS = 'iOS',
    Android = 'Android'
}

/**
 * 
 * @export
 * @interface TripCoordinate
 */
export interface TripCoordinate {
    /**
     * 
     * @type {number}
     * @memberof TripCoordinate
     */
    Latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof TripCoordinate
     */
    Longitude?: number;
}
/**
 * A request object for updating a new geofence
 * @export
 * @interface UpdateGeoFenceRequest
 */
export interface UpdateGeoFenceRequest {
    /**
     * The ID of the geofence you want to update
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    GeofenceId?: number;
    /**
     * The name of the geo fence
     * @type {string}
     * @memberof UpdateGeoFenceRequest
     */
    Name?: string;
    /**
     * A list of coordinates specifying the geofence region
     * @type {Array<BasicCoordinate>}
     * @memberof UpdateGeoFenceRequest
     */
    FenceCoordinates?: Array<BasicCoordinate>;
    /**
     * The job code to be used when the person enters/leaves the geofence
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    TriggerJobCodeId?: number;
    /**
     * The task to be used when the person enters/leaves the geofence
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    TriggerTaskId?: number;
    /**
     * Send an alert to a user, specified by their user ID
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    SendAlertToOrgGroupId?: number;
    /**
     * Define when you want the alerts to be setn
     * @type {string}
     * @memberof UpdateGeoFenceRequest
     */
    AlertSettings?: UpdateGeoFenceRequestAlertSettingsEnum;
    /**
     * Define how to you want to trigger the timesheet automation
     * @type {string}
     * @memberof UpdateGeoFenceRequest
     */
    TriggerSettings?: UpdateGeoFenceRequestTriggerSettingsEnum;
    /**
     * The start hour in which this geofence should apply.  After this time, the geofence will be active.
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    StartTimeHour?: number;
    /**
     * The start minute in which this geofence should apply.  After this time, the geofence will be active.
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    StartTimeMinute?: number;
    /**
     * The end hour in which this geofence will stop applying.  After this time, the geofence will be inactive.
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    EndTimeHour?: number;
    /**
     * The end minute in which this geofence will stop applying.  After this time, the geofence will be inactive.
     * @type {number}
     * @memberof UpdateGeoFenceRequest
     */
    EndTimeMinute?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateGeoFenceRequestAlertSettingsEnum {
    None = 'None',
    SendWhenEntering = 'SendWhenEntering',
    SendWhenExiting = 'SendWhenExiting',
    SendWhenEnteringOrExiting = 'SendWhenEnteringOrExiting'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateGeoFenceRequestTriggerSettingsEnum {
    None = 'None',
    StartTimesheetWhenEntering = 'StartTimesheetWhenEntering',
    StopTimesheetWhenEntering = 'StopTimesheetWhenEntering',
    StartOnEnterStopOnLeave = 'StartOnEnterStopOnLeave'
}

/**
 * Fields used to update an existing JobCode
 * @export
 * @interface UpdateJobCodeRequest
 */
export interface UpdateJobCodeRequest {
    /**
     * The Id of the JobCode to be updated
     * @type {number}
     * @memberof UpdateJobCodeRequest
     */
    Id?: number;
    /**
     * The new JobCode to be set
     * @type {string}
     * @memberof UpdateJobCodeRequest
     */
    Code?: string;
    /**
     * The Id of the Project to be associated to
     * @type {number}
     * @memberof UpdateJobCodeRequest
     */
    ProjectId?: number;
    /**
     * The Id of the Client to be associated to
     * @type {number}
     * @memberof UpdateJobCodeRequest
     */
    ClientId?: number;
    /**
     * A collection of Task Ids to be available when choosing this JobCode
     * @type {Array<number>}
     * @memberof UpdateJobCodeRequest
     */
    LinkedTaskIds?: Array<number>;
    /**
     * Restrict the access to this JobCode by specifying which Organisation Groups can have access.  Only employees in these Organisation Groups will be able to access this JobCode
     * @type {Array<number>}
     * @memberof UpdateJobCodeRequest
     */
    LinkedOrgGroupIds?: Array<number>;
    /**
     * Whether or not this JobCode is to be marked as deleted
     * @type {boolean}
     * @memberof UpdateJobCodeRequest
     */
    IsDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMyProfileRequest
 */
export interface UpdateMyProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    EmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    LastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    OldPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    NewPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileRequest
     */
    ConfirmNewPassword?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMyProfileRequest
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMyProfileRequest
     */
    WantsToChangePassword?: boolean;
}
/**
 * Field for updating your Organisation
 * @export
 * @interface UpdateOrganisationRequest
 */
export interface UpdateOrganisationRequest {
    /**
     * The Id of your Organisation.  This is validated based on your current Auth Token
     * @type {number}
     * @memberof UpdateOrganisationRequest
     */
    OrgansationId?: number;
    /**
     * The updated organisation name
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationName?: string;
    /**
     * The updated Address Line 1 value
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    AddressLine01?: string;
    /**
     * The updated Address Line 2 value
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    AddressLine02?: string;
    /**
     * The updated address suburb
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationSuburb?: string;
    /**
     * The updated address state
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationState?: string;
    /**
     * The updated address postcode
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationPostcode?: string;
    /**
     * The updated address country
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationCountry?: string;
    /**
     * The updated contact phone number
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationPhone?: string;
    /**
     * The update organisation email address
     * @type {string}
     * @memberof UpdateOrganisationRequest
     */
    OrganisationEmailAddress?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrganisationResponse
 */
export interface UpdateOrganisationResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateOrganisationResponse
     */
    ValidationErrors?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProfileResponse
 */
export interface UpdateProfileResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateProfileResponse
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfileResponse
     */
    UserId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProfileResponse
     */
    ValidationErrors?: Array<string>;
}
/**
 * Fields for updating a project
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * The Id of the Project that is to be updated
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    ProjectId?: number;
    /**
     * The new name of the Project
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    ProjectName?: string;
    /**
     * The updated estimated cost of the Project
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    CostEstimation?: number;
    /**
     * The updated project start date
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    StartDate?: string;
    /**
     * The update project end date
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    EndDate?: string;
}
/**
 * Fields used to update a Task
 * @export
 * @interface UpdateTaskRequest
 */
export interface UpdateTaskRequest {
    /**
     * The Id of the Task that is to be updated
     * @type {number}
     * @memberof UpdateTaskRequest
     */
    Id?: number;
    /**
     * The updated Task Name
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    TaskName?: string;
    /**
     * Whether or not this Task should be marked as deleted
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    IsDeleted?: boolean;
    /**
     * Whether or not this Task should have GPS Trip Recording enabled
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    TripEnabled?: boolean;
}
/**
 * Fields for updating an employee User Account
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * The Id of the User that is to be updated
     * @type {number}
     * @memberof UpdateUserRequest
     */
    UserId?: number;
    /**
     * The Email Address of the employee
     * @type {string}
     * @memberof UpdateUserRequest
     */
    EmailAddress?: string;
    /**
     * The First Name of the employee
     * @type {string}
     * @memberof UpdateUserRequest
     */
    FirstName?: string;
    /**
     * The Last Name of the employee
     * @type {string}
     * @memberof UpdateUserRequest
     */
    LastName?: string;
    /**
     * Whether or not the employee is subscribed to ChronoSheets newsletters
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * Whether or not the employee account is active
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    IsAccountActive?: boolean;
    /**
     * A BIT field designating which Roles/Permissions the employee will have when they sign in.  See the {timesheets.types.Enums.UserRoles} Enum for more details
     * @type {number}
     * @memberof UpdateUserRequest
     */
    Roles?: number;
    /**
     * A BIT field designating which Alerts the employee will receive.  See the {timesheets.types.Enums.AlertSettings} Enum for more details
     * @type {number}
     * @memberof UpdateUserRequest
     */
    AlertSettings?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserResponse
 */
export interface UpdateUserResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateUserResponse
     */
    OrganisationId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserResponse
     */
    UserId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserResponse
     */
    ValidationErrors?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserForManagement
 */
export interface UserForManagement {
    /**
     * 
     * @type {boolean}
     * @memberof UserForManagement
     */
    IsAccountActive?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserForManagement
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof UserForManagement
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserForManagement
     */
    UserName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserForManagement
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserForManagement
     */
    LastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserForManagement
     */
    EmailAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof UserForManagement
     */
    Roles?: number;
    /**
     * 
     * @type {number}
     * @memberof UserForManagement
     */
    AlertSettings?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserForManagement
     */
    SetupWizardRequired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserForManagement
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * 
     * @type {Organisation}
     * @memberof UserForManagement
     */
    Organisation?: Organisation;
    /**
     * 
     * @type {boolean}
     * @memberof UserForManagement
     */
    IsPrimaryAccount?: boolean;
}
/**
 * 
 * @export
 * @interface UserHourlyRate
 */
export interface UserHourlyRate {
    /**
     * 
     * @type {number}
     * @memberof UserHourlyRate
     */
    RateId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserHourlyRate
     */
    UserId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserHourlyRate
     */
    OrganisationId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserHourlyRate
     */
    IsCurrent?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserHourlyRate
     */
    HourlyRate?: number;
    /**
     * 
     * @type {number}
     * @memberof UserHourlyRate
     */
    HourlyOvertimeRate?: number;
    /**
     * 
     * @type {string}
     * @memberof UserHourlyRate
     */
    StartDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof UserHourlyRate
     */
    EndDateTime?: string;
}
/**
 * 
 * @export
 * @interface UserJobFavourite
 */
export interface UserJobFavourite {
    /**
     * 
     * @type {number}
     * @memberof UserJobFavourite
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof UserJobFavourite
     */
    JobId?: number;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    Id?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    OrganisationId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    UserName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    LastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    EmailAddress?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfile
     */
    IsSubscribedToNewsletter?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    Roles?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    AlertSettings?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    OrganisationName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    OrganisationSuburb?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    OrganisationCountry?: string;
}
/**
 * 
 * @export
 * @interface UsualHoursDay
 */
export interface UsualHoursDay {
    /**
     * Specify which day this collection of Roster timeslots is for (Monday-Sunday)
     * @type {string}
     * @memberof UsualHoursDay
     */
    DayType?: UsualHoursDayDayTypeEnum;
    /**
     * A collection of TimeSlots within this day
     * @type {Array<TimeSlot>}
     * @memberof UsualHoursDay
     */
    TimeSlots?: Array<TimeSlot>;
    /**
     * Mark here which existing UsualHours are to be deleted
     * @type {Array<number>}
     * @memberof UsualHoursDay
     */
    DeleteUsualHours?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum UsualHoursDayDayTypeEnum {
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday',
    Sunday = 'Sunday'
}


/**
 * AggregateClientProjectsApi - axios parameter creator
 * @export
 */
export const AggregateClientProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get client and project information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageClientsAndProjects\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateClientProjectsGetAggregateClientProjects: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling aggregateClientProjectsGetAggregateClientProjects.');
            }
            const localVarPath = `/AggregateClientProjects/GetAggregateClientProjects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregateClientProjectsApi - functional programming interface
 * @export
 */
export const AggregateClientProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get client and project information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageClientsAndProjects\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListAggregateClient>> {
            const localVarAxiosArgs = await AggregateClientProjectsApiAxiosParamCreator(configuration).aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AggregateClientProjectsApi - factory interface
 * @export
 */
export const AggregateClientProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get client and project information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageClientsAndProjects\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListAggregateClient> {
            return AggregateClientProjectsApiFp(configuration).aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AggregateClientProjectsApi - object-oriented interface
 * @export
 * @class AggregateClientProjectsApi
 * @extends {BaseAPI}
 */
export class AggregateClientProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Get client and project information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageClientsAndProjects\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregateClientProjectsApi
     */
    public aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth: string, options?: any) {
        return AggregateClientProjectsApiFp(this.configuration).aggregateClientProjectsGetAggregateClientProjects(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AggregateJobTasksApi - axios parameter creator
 * @export
 */
export const AggregateJobTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get jobs and tasks information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateJobTasksGetAggregateJobTasks: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling aggregateJobTasksGetAggregateJobTasks.');
            }
            const localVarPath = `/AggregateJobTasks/GetAggregateJobTasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregateJobTasksApi - functional programming interface
 * @export
 */
export const AggregateJobTasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get jobs and tasks information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListAggregateJobCode>> {
            const localVarAxiosArgs = await AggregateJobTasksApiAxiosParamCreator(configuration).aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AggregateJobTasksApi - factory interface
 * @export
 */
export const AggregateJobTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get jobs and tasks information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListAggregateJobCode> {
            return AggregateJobTasksApiFp(configuration).aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AggregateJobTasksApi - object-oriented interface
 * @export
 * @class AggregateJobTasksApi
 * @extends {BaseAPI}
 */
export class AggregateJobTasksApi extends BaseAPI {
    /**
     * 
     * @summary Get jobs and tasks information, aggregated.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregateJobTasksApi
     */
    public aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth: string, options?: any) {
        return AggregateJobTasksApiFp(this.configuration).aggregateJobTasksGetAggregateJobTasks(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertClientRequest} request An Insert Client Request object containing values for the new Client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsCreateClient: async (xChronosheetsAuth: string, request: InsertClientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling clientsCreateClient.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling clientsCreateClient.');
            }
            const localVarPath = `/Clients/CreateClient`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the Client you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGetClient: async (clientId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling clientsGetClient.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling clientsGetClient.');
            }
            const localVarPath = `/Clients/GetClient`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['ClientId'] = clientId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection of clients that are under your organisation.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGetClients: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling clientsGetClients.');
            }
            const localVarPath = `/Clients/GetClients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveClientRequest} request A Save Client Request object containing updated fields.  Make sure to specify the Client Id in the request object so that ChronoSheets knows which Client to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsUpdateClient: async (xChronosheetsAuth: string, request: SaveClientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling clientsUpdateClient.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling clientsUpdateClient.');
            }
            const localVarPath = `/Clients/UpdateClient`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertClientRequest} request An Insert Client Request object containing values for the new Client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsCreateClient(xChronosheetsAuth: string, request: InsertClientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsCreateClient(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the Client you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsGetClient(clientId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseClient>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsGetClient(clientId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a collection of clients that are under your organisation.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsGetClients(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListClient>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsGetClients(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveClientRequest} request A Save Client Request object containing updated fields.  Make sure to specify the Client Id in the request object so that ChronoSheets knows which Client to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsUpdateClient(xChronosheetsAuth: string, request: SaveClientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsUpdateClient(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertClientRequest} request An Insert Client Request object containing values for the new Client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsCreateClient(xChronosheetsAuth: string, request: InsertClientRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return ClientsApiFp(configuration).clientsCreateClient(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the Client you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGetClient(clientId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseClient> {
            return ClientsApiFp(configuration).clientsGetClient(clientId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a collection of clients that are under your organisation.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGetClients(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListClient> {
            return ClientsApiFp(configuration).clientsGetClients(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a client.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveClientRequest} request A Save Client Request object containing updated fields.  Make sure to specify the Client Id in the request object so that ChronoSheets knows which Client to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsUpdateClient(xChronosheetsAuth: string, request: SaveClientRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return ClientsApiFp(configuration).clientsUpdateClient(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @summary Create a client.    Requires the \'ManageClientsAndProjects\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertClientRequest} request An Insert Client Request object containing values for the new Client to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsCreateClient(xChronosheetsAuth: string, request: InsertClientRequest, options?: any) {
        return ClientsApiFp(this.configuration).clientsCreateClient(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
     * @param {number} clientId The ID of the Client you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsGetClient(clientId: number, xChronosheetsAuth: string, options?: any) {
        return ClientsApiFp(this.configuration).clientsGetClient(clientId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a collection of clients that are under your organisation.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsGetClients(xChronosheetsAuth: string, options?: any) {
        return ClientsApiFp(this.configuration).clientsGetClients(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a client.    Requires the \'ManageClientsAndProjects\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {SaveClientRequest} request A Save Client Request object containing updated fields.  Make sure to specify the Client Id in the request object so that ChronoSheets knows which Client to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsUpdateClient(xChronosheetsAuth: string, request: SaveClientRequest, options?: any) {
        return ClientsApiFp(this.configuration).clientsUpdateClient(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FileAttachmentsApi - axios parameter creator
 * @export
 */
export const FileAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a particular timesheet file attachment  Requires the \'SubmitTimesheets\' permission.
         * @param {number} fileAttachmentId The Id of the file attachment to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsDeleteTimesheetFileAttachment: async (fileAttachmentId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileAttachmentId' is not null or undefined
            if (fileAttachmentId === null || fileAttachmentId === undefined) {
                throw new RequiredError('fileAttachmentId','Required parameter fileAttachmentId was null or undefined when calling fileAttachmentsDeleteTimesheetFileAttachment.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fileAttachmentsDeleteTimesheetFileAttachment.');
            }
            const localVarPath = `/FileAttachments/DeleteTimesheetFileAttachment`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileAttachmentId !== undefined) {
                localVarQueryParameter['FileAttachmentId'] = fileAttachmentId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular file attachment by ID.  User must own the file attachment for access.
         * @param {number} fileAttachmentId The ID of the file attachment
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsGetFileAttachmentById: async (fileAttachmentId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileAttachmentId' is not null or undefined
            if (fileAttachmentId === null || fileAttachmentId === undefined) {
                throw new RequiredError('fileAttachmentId','Required parameter fileAttachmentId was null or undefined when calling fileAttachmentsGetFileAttachmentById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fileAttachmentsGetFileAttachmentById.');
            }
            const localVarPath = `/FileAttachments/GetFileAttachmentById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileAttachmentId !== undefined) {
                localVarQueryParameter['FileAttachmentId'] = fileAttachmentId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my file attachments.  Get files you\'ve attached to timesheets.
         * @param {string} startDate The Start date of the date range.  File attachments after this date will be obtained.
         * @param {string} endDate The End date of the date range.  File attachments before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many File attachments
         * @param {number} [take] Take this many File attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsGetMyFileAttachments: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling fileAttachmentsGetMyFileAttachments.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling fileAttachmentsGetMyFileAttachments.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fileAttachmentsGetMyFileAttachments.');
            }
            const localVarPath = `/FileAttachments/GetMyFileAttachments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileAttachmentsApi - functional programming interface
 * @export
 */
export const FileAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a particular timesheet file attachment  Requires the \'SubmitTimesheets\' permission.
         * @param {number} fileAttachmentId The Id of the file attachment to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await FileAttachmentsApiAxiosParamCreator(configuration).fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular file attachment by ID.  User must own the file attachment for access.
         * @param {number} fileAttachmentId The ID of the file attachment
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileAttachmentsGetFileAttachmentById(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTimesheetFileAttachment>> {
            const localVarAxiosArgs = await FileAttachmentsApiAxiosParamCreator(configuration).fileAttachmentsGetFileAttachmentById(fileAttachmentId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get my file attachments.  Get files you\'ve attached to timesheets.
         * @param {string} startDate The Start date of the date range.  File attachments after this date will be obtained.
         * @param {string} endDate The End date of the date range.  File attachments before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many File attachments
         * @param {number} [take] Take this many File attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileAttachmentsGetMyFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListTimesheetFileAttachment>> {
            const localVarAxiosArgs = await FileAttachmentsApiAxiosParamCreator(configuration).fileAttachmentsGetMyFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FileAttachmentsApi - factory interface
 * @export
 */
export const FileAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a particular timesheet file attachment  Requires the \'SubmitTimesheets\' permission.
         * @param {number} fileAttachmentId The Id of the file attachment to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return FileAttachmentsApiFp(configuration).fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular file attachment by ID.  User must own the file attachment for access.
         * @param {number} fileAttachmentId The ID of the file attachment
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsGetFileAttachmentById(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseTimesheetFileAttachment> {
            return FileAttachmentsApiFp(configuration).fileAttachmentsGetFileAttachmentById(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my file attachments.  Get files you\'ve attached to timesheets.
         * @param {string} startDate The Start date of the date range.  File attachments after this date will be obtained.
         * @param {string} endDate The End date of the date range.  File attachments before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many File attachments
         * @param {number} [take] Take this many File attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileAttachmentsGetMyFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, options?: any): AxiosPromise<ApiResponseForPaginatedListTimesheetFileAttachment> {
            return FileAttachmentsApiFp(configuration).fileAttachmentsGetMyFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileAttachmentsApi - object-oriented interface
 * @export
 * @class FileAttachmentsApi
 * @extends {BaseAPI}
 */
export class FileAttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a particular timesheet file attachment  Requires the \'SubmitTimesheets\' permission.
     * @param {number} fileAttachmentId The Id of the file attachment to delete
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId: number, xChronosheetsAuth: string, options?: any) {
        return FileAttachmentsApiFp(this.configuration).fileAttachmentsDeleteTimesheetFileAttachment(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular file attachment by ID.  User must own the file attachment for access.
     * @param {number} fileAttachmentId The ID of the file attachment
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public fileAttachmentsGetFileAttachmentById(fileAttachmentId: number, xChronosheetsAuth: string, options?: any) {
        return FileAttachmentsApiFp(this.configuration).fileAttachmentsGetFileAttachmentById(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my file attachments.  Get files you\'ve attached to timesheets.
     * @param {string} startDate The Start date of the date range.  File attachments after this date will be obtained.
     * @param {string} endDate The End date of the date range.  File attachments before this date will be obtained.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many File attachments
     * @param {number} [take] Take this many File attachments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public fileAttachmentsGetMyFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, options?: any) {
        return FileAttachmentsApiFp(this.configuration).fileAttachmentsGetMyFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FleetApi - axios parameter creator
 * @export
 */
export const FleetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertVehicleRequest} request An Insert Vehicle Request object containing values for the new Vehicle to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetCreateVehicle: async (xChronosheetsAuth: string, request: InsertVehicleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fleetCreateVehicle.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling fleetCreateVehicle.');
            }
            const localVarPath = `/Fleet/CreateVehicle`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vehicle from the fleet.  Requires the \'ManageFleet\' permission.
         * @param {number} vehicleId The unique ID of the vehicle you wish to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetDeleteVehicle: async (vehicleId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            if (vehicleId === null || vehicleId === undefined) {
                throw new RequiredError('vehicleId','Required parameter vehicleId was null or undefined when calling fleetDeleteVehicle.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fleetDeleteVehicle.');
            }
            const localVarPath = `/Fleet/DeleteVehicle`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['VehicleId'] = vehicleId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular vehicle.  Does not require any special permission.
         * @param {number} vehicleId The ID of the Vehicle you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetGetVehicleById: async (vehicleId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            if (vehicleId === null || vehicleId === undefined) {
                throw new RequiredError('vehicleId','Required parameter vehicleId was null or undefined when calling fleetGetVehicleById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fleetGetVehicleById.');
            }
            const localVarPath = `/Fleet/GetVehicleById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['VehicleId'] = vehicleId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection of vehicles that are under your organisation.    Does not require any special permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {boolean} [includeDeleted] Whether or not to include deleted vehicles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetGetVehicles: async (xChronosheetsAuth: string, includeDeleted?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fleetGetVehicles.');
            }
            const localVarPath = `/Fleet/GetVehicles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeDeleted !== undefined) {
                localVarQueryParameter['IncludeDeleted'] = includeDeleted;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveVehicleRequest} request A Save Vehicle Request object containing updated fields.  Make sure to specify the Vehicle Id in the request object so that ChronoSheets knows which Vehicle to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetUpdateVehicle: async (xChronosheetsAuth: string, request: SaveVehicleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling fleetUpdateVehicle.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling fleetUpdateVehicle.');
            }
            const localVarPath = `/Fleet/UpdateVehicle`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FleetApi - functional programming interface
 * @export
 */
export const FleetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertVehicleRequest} request An Insert Vehicle Request object containing values for the new Vehicle to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fleetCreateVehicle(xChronosheetsAuth: string, request: InsertVehicleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await FleetApiAxiosParamCreator(configuration).fleetCreateVehicle(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a vehicle from the fleet.  Requires the \'ManageFleet\' permission.
         * @param {number} vehicleId The unique ID of the vehicle you wish to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fleetDeleteVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await FleetApiAxiosParamCreator(configuration).fleetDeleteVehicle(vehicleId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular vehicle.  Does not require any special permission.
         * @param {number} vehicleId The ID of the Vehicle you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fleetGetVehicleById(vehicleId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseFleetVehicle>> {
            const localVarAxiosArgs = await FleetApiAxiosParamCreator(configuration).fleetGetVehicleById(vehicleId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a collection of vehicles that are under your organisation.    Does not require any special permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {boolean} [includeDeleted] Whether or not to include deleted vehicles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fleetGetVehicles(xChronosheetsAuth: string, includeDeleted?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListFleetVehicle>> {
            const localVarAxiosArgs = await FleetApiAxiosParamCreator(configuration).fleetGetVehicles(xChronosheetsAuth, includeDeleted, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveVehicleRequest} request A Save Vehicle Request object containing updated fields.  Make sure to specify the Vehicle Id in the request object so that ChronoSheets knows which Vehicle to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fleetUpdateVehicle(xChronosheetsAuth: string, request: SaveVehicleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await FleetApiAxiosParamCreator(configuration).fleetUpdateVehicle(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FleetApi - factory interface
 * @export
 */
export const FleetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertVehicleRequest} request An Insert Vehicle Request object containing values for the new Vehicle to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetCreateVehicle(xChronosheetsAuth: string, request: InsertVehicleRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return FleetApiFp(configuration).fleetCreateVehicle(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vehicle from the fleet.  Requires the \'ManageFleet\' permission.
         * @param {number} vehicleId The unique ID of the vehicle you wish to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetDeleteVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return FleetApiFp(configuration).fleetDeleteVehicle(vehicleId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular vehicle.  Does not require any special permission.
         * @param {number} vehicleId The ID of the Vehicle you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetGetVehicleById(vehicleId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseFleetVehicle> {
            return FleetApiFp(configuration).fleetGetVehicleById(vehicleId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a collection of vehicles that are under your organisation.    Does not require any special permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {boolean} [includeDeleted] Whether or not to include deleted vehicles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetGetVehicles(xChronosheetsAuth: string, includeDeleted?: boolean, options?: any): AxiosPromise<ApiResponseListFleetVehicle> {
            return FleetApiFp(configuration).fleetGetVehicles(xChronosheetsAuth, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vehicle.    Requires the \'ManageFleet\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveVehicleRequest} request A Save Vehicle Request object containing updated fields.  Make sure to specify the Vehicle Id in the request object so that ChronoSheets knows which Vehicle to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fleetUpdateVehicle(xChronosheetsAuth: string, request: SaveVehicleRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return FleetApiFp(configuration).fleetUpdateVehicle(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FleetApi - object-oriented interface
 * @export
 * @class FleetApi
 * @extends {BaseAPI}
 */
export class FleetApi extends BaseAPI {
    /**
     * 
     * @summary Create a vehicle.    Requires the \'ManageFleet\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertVehicleRequest} request An Insert Vehicle Request object containing values for the new Vehicle to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public fleetCreateVehicle(xChronosheetsAuth: string, request: InsertVehicleRequest, options?: any) {
        return FleetApiFp(this.configuration).fleetCreateVehicle(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vehicle from the fleet.  Requires the \'ManageFleet\' permission.
     * @param {number} vehicleId The unique ID of the vehicle you wish to delete
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public fleetDeleteVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any) {
        return FleetApiFp(this.configuration).fleetDeleteVehicle(vehicleId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular vehicle.  Does not require any special permission.
     * @param {number} vehicleId The ID of the Vehicle you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public fleetGetVehicleById(vehicleId: number, xChronosheetsAuth: string, options?: any) {
        return FleetApiFp(this.configuration).fleetGetVehicleById(vehicleId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a collection of vehicles that are under your organisation.    Does not require any special permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {boolean} [includeDeleted] Whether or not to include deleted vehicles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public fleetGetVehicles(xChronosheetsAuth: string, includeDeleted?: boolean, options?: any) {
        return FleetApiFp(this.configuration).fleetGetVehicles(xChronosheetsAuth, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vehicle.    Requires the \'ManageFleet\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {SaveVehicleRequest} request A Save Vehicle Request object containing updated fields.  Make sure to specify the Vehicle Id in the request object so that ChronoSheets knows which Vehicle to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetApi
     */
    public fleetUpdateVehicle(xChronosheetsAuth: string, request: SaveVehicleRequest, options?: any) {
        return FleetApiFp(this.configuration).fleetUpdateVehicle(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GeoFencingApi - axios parameter creator
 * @export
 */
export const GeoFencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingCreateGeofence: async (xChronosheetsAuth: string, request: CreateGeoFenceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling geoFencingCreateGeofence.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling geoFencingCreateGeofence.');
            }
            const localVarPath = `/GeoFencing/CreateGeofence`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a geofence.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId Specify the geofence you want to delete with the geofence ID.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingDeleteGeofence: async (geofenceId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'geofenceId' is not null or undefined
            if (geofenceId === null || geofenceId === undefined) {
                throw new RequiredError('geofenceId','Required parameter geofenceId was null or undefined when calling geoFencingDeleteGeofence.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling geoFencingDeleteGeofence.');
            }
            const localVarPath = `/GeoFencing/DeleteGeofence`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (geofenceId !== undefined) {
                localVarQueryParameter['GeofenceId'] = geofenceId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a geofence by ID  Requires the \'SubmitTimesheets\' permission.
         * @param {number} geofenceId The ID of the geofence you want to obtain
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingGetGeofenceById: async (geofenceId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'geofenceId' is not null or undefined
            if (geofenceId === null || geofenceId === undefined) {
                throw new RequiredError('geofenceId','Required parameter geofenceId was null or undefined when calling geoFencingGetGeofenceById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling geoFencingGetGeofenceById.');
            }
            const localVarPath = `/GeoFencing/GetGeofenceById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (geofenceId !== undefined) {
                localVarQueryParameter['GeofenceId'] = geofenceId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get geofences belonging to your organisation  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Number of records to skip
         * @param {number} [take] Number of records to take
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingGetGeofences: async (xChronosheetsAuth: string, skip?: number, take?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling geoFencingGetGeofences.');
            }
            const localVarPath = `/GeoFencing/GetGeofences`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingUpdateGeofence: async (xChronosheetsAuth: string, request: UpdateGeoFenceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling geoFencingUpdateGeofence.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling geoFencingUpdateGeofence.');
            }
            const localVarPath = `/GeoFencing/UpdateGeofence`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoFencingApi - functional programming interface
 * @export
 */
export const GeoFencingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoFencingCreateGeofence(xChronosheetsAuth: string, request: CreateGeoFenceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await GeoFencingApiAxiosParamCreator(configuration).geoFencingCreateGeofence(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a geofence.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId Specify the geofence you want to delete with the geofence ID.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoFencingDeleteGeofence(geofenceId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseGeofence>> {
            const localVarAxiosArgs = await GeoFencingApiAxiosParamCreator(configuration).geoFencingDeleteGeofence(geofenceId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a geofence by ID  Requires the \'SubmitTimesheets\' permission.
         * @param {number} geofenceId The ID of the geofence you want to obtain
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoFencingGetGeofenceById(geofenceId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseGeofence>> {
            const localVarAxiosArgs = await GeoFencingApiAxiosParamCreator(configuration).geoFencingGetGeofenceById(geofenceId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get geofences belonging to your organisation  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Number of records to skip
         * @param {number} [take] Number of records to take
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoFencingGetGeofences(xChronosheetsAuth: string, skip?: number, take?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListExtendedGeofence>> {
            const localVarAxiosArgs = await GeoFencingApiAxiosParamCreator(configuration).geoFencingGetGeofences(xChronosheetsAuth, skip, take, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoFencingUpdateGeofence(xChronosheetsAuth: string, request: UpdateGeoFenceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await GeoFencingApiAxiosParamCreator(configuration).geoFencingUpdateGeofence(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GeoFencingApi - factory interface
 * @export
 */
export const GeoFencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingCreateGeofence(xChronosheetsAuth: string, request: CreateGeoFenceRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return GeoFencingApiFp(configuration).geoFencingCreateGeofence(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a geofence.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId Specify the geofence you want to delete with the geofence ID.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingDeleteGeofence(geofenceId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseGeofence> {
            return GeoFencingApiFp(configuration).geoFencingDeleteGeofence(geofenceId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a geofence by ID  Requires the \'SubmitTimesheets\' permission.
         * @param {number} geofenceId The ID of the geofence you want to obtain
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingGetGeofenceById(geofenceId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseGeofence> {
            return GeoFencingApiFp(configuration).geoFencingGetGeofenceById(geofenceId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get geofences belonging to your organisation  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Number of records to skip
         * @param {number} [take] Number of records to take
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingGetGeofences(xChronosheetsAuth: string, skip?: number, take?: number, options?: any): AxiosPromise<ApiResponseForPaginatedListExtendedGeofence> {
            return GeoFencingApiFp(configuration).geoFencingGetGeofences(xChronosheetsAuth, skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateGeoFenceRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoFencingUpdateGeofence(xChronosheetsAuth: string, request: UpdateGeoFenceRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return GeoFencingApiFp(configuration).geoFencingUpdateGeofence(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeoFencingApi - object-oriented interface
 * @export
 * @class GeoFencingApi
 * @extends {BaseAPI}
 */
export class GeoFencingApi extends BaseAPI {
    /**
     * 
     * @summary Create a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {CreateGeoFenceRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoFencingApi
     */
    public geoFencingCreateGeofence(xChronosheetsAuth: string, request: CreateGeoFenceRequest, options?: any) {
        return GeoFencingApiFp(this.configuration).geoFencingCreateGeofence(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a geofence.  Requires the \'ManageGeofencing\' permission.
     * @param {number} geofenceId Specify the geofence you want to delete with the geofence ID.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoFencingApi
     */
    public geoFencingDeleteGeofence(geofenceId: number, xChronosheetsAuth: string, options?: any) {
        return GeoFencingApiFp(this.configuration).geoFencingDeleteGeofence(geofenceId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a geofence by ID  Requires the \'SubmitTimesheets\' permission.
     * @param {number} geofenceId The ID of the geofence you want to obtain
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoFencingApi
     */
    public geoFencingGetGeofenceById(geofenceId: number, xChronosheetsAuth: string, options?: any) {
        return GeoFencingApiFp(this.configuration).geoFencingGetGeofenceById(geofenceId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get geofences belonging to your organisation  Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Number of records to skip
     * @param {number} [take] Number of records to take
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoFencingApi
     */
    public geoFencingGetGeofences(xChronosheetsAuth: string, skip?: number, take?: number, options?: any) {
        return GeoFencingApiFp(this.configuration).geoFencingGetGeofences(xChronosheetsAuth, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a geofencing with rules to be used for clock on/off automation.  Requires the \'ManageGeofencing\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateGeoFenceRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoFencingApi
     */
    public geoFencingUpdateGeofence(xChronosheetsAuth: string, request: UpdateGeoFenceRequest, options?: any) {
        return GeoFencingApiFp(this.configuration).geoFencingUpdateGeofence(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * JobCodesApi - axios parameter creator
 * @export
 */
export const JobCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertJobCodeRequest} request An Insert JobCode Request object containing values for the new JobCode to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesCreateJobCode: async (xChronosheetsAuth: string, request: InsertJobCodeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling jobCodesCreateJobCode.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling jobCodesCreateJobCode.');
            }
            const localVarPath = `/JobCodes/CreateJobCode`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} jobCodeId The ID of the job code you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesDeleteJobCode: async (jobCodeId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobCodeId' is not null or undefined
            if (jobCodeId === null || jobCodeId === undefined) {
                throw new RequiredError('jobCodeId','Required parameter jobCodeId was null or undefined when calling jobCodesDeleteJobCode.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling jobCodesDeleteJobCode.');
            }
            const localVarPath = `/JobCodes/DeleteJobCode`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobCodeId !== undefined) {
                localVarQueryParameter['JobCodeId'] = jobCodeId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular job code by job code id.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {number} jobCodeId The ID of the JobCode you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesGetJobCodeById: async (jobCodeId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobCodeId' is not null or undefined
            if (jobCodeId === null || jobCodeId === undefined) {
                throw new RequiredError('jobCodeId','Required parameter jobCodeId was null or undefined when calling jobCodesGetJobCodeById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling jobCodesGetJobCodeById.');
            }
            const localVarPath = `/JobCodes/GetJobCodeById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobCodeId !== undefined) {
                localVarQueryParameter['JobCodeId'] = jobCodeId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job codes for your organisation.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesGetJobCodes: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling jobCodesGetJobCodes.');
            }
            const localVarPath = `/JobCodes/GetJobCodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateJobCodeRequest} request A Update JobCode Request object containing updated fields.  Make sure to specify the JobCode Id in the request object so that ChronoSheets knows which JobCode to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesUpdateJobCode: async (xChronosheetsAuth: string, request: UpdateJobCodeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling jobCodesUpdateJobCode.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling jobCodesUpdateJobCode.');
            }
            const localVarPath = `/JobCodes/UpdateJobCode`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobCodesApi - functional programming interface
 * @export
 */
export const JobCodesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertJobCodeRequest} request An Insert JobCode Request object containing values for the new JobCode to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobCodesCreateJobCode(xChronosheetsAuth: string, request: InsertJobCodeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await JobCodesApiAxiosParamCreator(configuration).jobCodesCreateJobCode(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} jobCodeId The ID of the job code you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobCodesDeleteJobCode(jobCodeId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await JobCodesApiAxiosParamCreator(configuration).jobCodesDeleteJobCode(jobCodeId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular job code by job code id.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {number} jobCodeId The ID of the JobCode you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobCodesGetJobCodeById(jobCodeId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseJobCode>> {
            const localVarAxiosArgs = await JobCodesApiAxiosParamCreator(configuration).jobCodesGetJobCodeById(jobCodeId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get job codes for your organisation.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobCodesGetJobCodes(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListJobCode>> {
            const localVarAxiosArgs = await JobCodesApiAxiosParamCreator(configuration).jobCodesGetJobCodes(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateJobCodeRequest} request A Update JobCode Request object containing updated fields.  Make sure to specify the JobCode Id in the request object so that ChronoSheets knows which JobCode to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobCodesUpdateJobCode(xChronosheetsAuth: string, request: UpdateJobCodeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await JobCodesApiAxiosParamCreator(configuration).jobCodesUpdateJobCode(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JobCodesApi - factory interface
 * @export
 */
export const JobCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertJobCodeRequest} request An Insert JobCode Request object containing values for the new JobCode to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesCreateJobCode(xChronosheetsAuth: string, request: InsertJobCodeRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return JobCodesApiFp(configuration).jobCodesCreateJobCode(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} jobCodeId The ID of the job code you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesDeleteJobCode(jobCodeId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return JobCodesApiFp(configuration).jobCodesDeleteJobCode(jobCodeId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular job code by job code id.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {number} jobCodeId The ID of the JobCode you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesGetJobCodeById(jobCodeId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseJobCode> {
            return JobCodesApiFp(configuration).jobCodesGetJobCodeById(jobCodeId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job codes for your organisation.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesGetJobCodes(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListJobCode> {
            return JobCodesApiFp(configuration).jobCodesGetJobCodes(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a job code.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateJobCodeRequest} request A Update JobCode Request object containing updated fields.  Make sure to specify the JobCode Id in the request object so that ChronoSheets knows which JobCode to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobCodesUpdateJobCode(xChronosheetsAuth: string, request: UpdateJobCodeRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return JobCodesApiFp(configuration).jobCodesUpdateJobCode(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobCodesApi - object-oriented interface
 * @export
 * @class JobCodesApi
 * @extends {BaseAPI}
 */
export class JobCodesApi extends BaseAPI {
    /**
     * 
     * @summary Create a job code.    Requires the \'ManageJobsAndTask\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertJobCodeRequest} request An Insert JobCode Request object containing values for the new JobCode to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobCodesApi
     */
    public jobCodesCreateJobCode(xChronosheetsAuth: string, request: InsertJobCodeRequest, options?: any) {
        return JobCodesApiFp(this.configuration).jobCodesCreateJobCode(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a job code.    Requires the \'ManageJobsAndTask\' permission.
     * @param {number} jobCodeId The ID of the job code you want to delete
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobCodesApi
     */
    public jobCodesDeleteJobCode(jobCodeId: number, xChronosheetsAuth: string, options?: any) {
        return JobCodesApiFp(this.configuration).jobCodesDeleteJobCode(jobCodeId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular job code by job code id.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
     * @param {number} jobCodeId The ID of the JobCode you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobCodesApi
     */
    public jobCodesGetJobCodeById(jobCodeId: number, xChronosheetsAuth: string, options?: any) {
        return JobCodesApiFp(this.configuration).jobCodesGetJobCodeById(jobCodeId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job codes for your organisation.    Requires \'SubmitTimesheets\' or \'ManageJobsAndTasks\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobCodesApi
     */
    public jobCodesGetJobCodes(xChronosheetsAuth: string, options?: any) {
        return JobCodesApiFp(this.configuration).jobCodesGetJobCodes(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a job code.    Requires the \'ManageJobsAndTask\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateJobCodeRequest} request A Update JobCode Request object containing updated fields.  Make sure to specify the JobCode Id in the request object so that ChronoSheets knows which JobCode to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobCodesApi
     */
    public jobCodesUpdateJobCode(xChronosheetsAuth: string, request: UpdateJobCodeRequest, options?: any) {
        return JobCodesApiFp(this.configuration).jobCodesUpdateJobCode(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganisationApi - axios parameter creator
 * @export
 */
export const OrganisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGetOrganisation: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGetOrganisation.');
            }
            const localVarPath = `/Organisation/GetOrganisation`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateOrganisationRequest} request An Update Organsation Request object containing updated fields.  Make sure to specify the Organsation Id in the request object so that ChronoSheets knows which Organsation to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationUpdateOrganisation: async (xChronosheetsAuth: string, request: UpdateOrganisationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationUpdateOrganisation.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling organisationUpdateOrganisation.');
            }
            const localVarPath = `/Organisation/UpdateOrganisation`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationApi - functional programming interface
 * @export
 */
export const OrganisationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGetOrganisation(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOrganisation>> {
            const localVarAxiosArgs = await OrganisationApiAxiosParamCreator(configuration).organisationGetOrganisation(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateOrganisationRequest} request An Update Organsation Request object containing updated fields.  Make sure to specify the Organsation Id in the request object so that ChronoSheets knows which Organsation to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationUpdateOrganisation(xChronosheetsAuth: string, request: UpdateOrganisationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUpdateOrganisationResponse>> {
            const localVarAxiosArgs = await OrganisationApiAxiosParamCreator(configuration).organisationUpdateOrganisation(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganisationApi - factory interface
 * @export
 */
export const OrganisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get your organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGetOrganisation(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseOrganisation> {
            return OrganisationApiFp(configuration).organisationGetOrganisation(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an organisation.    Requires \'OrganisationAdmin\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateOrganisationRequest} request An Update Organsation Request object containing updated fields.  Make sure to specify the Organsation Id in the request object so that ChronoSheets knows which Organsation to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationUpdateOrganisation(xChronosheetsAuth: string, request: UpdateOrganisationRequest, options?: any): AxiosPromise<ApiResponseUpdateOrganisationResponse> {
            return OrganisationApiFp(configuration).organisationUpdateOrganisation(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationApi - object-oriented interface
 * @export
 * @class OrganisationApi
 * @extends {BaseAPI}
 */
export class OrganisationApi extends BaseAPI {
    /**
     * 
     * @summary Get your organisation.    Requires \'OrganisationAdmin\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationApi
     */
    public organisationGetOrganisation(xChronosheetsAuth: string, options?: any) {
        return OrganisationApiFp(this.configuration).organisationGetOrganisation(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an organisation.    Requires \'OrganisationAdmin\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateOrganisationRequest} request An Update Organsation Request object containing updated fields.  Make sure to specify the Organsation Id in the request object so that ChronoSheets knows which Organsation to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationApi
     */
    public organisationUpdateOrganisation(xChronosheetsAuth: string, request: UpdateOrganisationRequest, options?: any) {
        return OrganisationApiFp(this.configuration).organisationUpdateOrganisation(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganisationGroupUsersApi - axios parameter creator
 * @export
 */
export const OrganisationGroupUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a collection of organisation group users that belong to an organisation group.    Requires the \'ManageOrganisationGroups\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} orgGroupId An OrganisationGroup Id
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupUsersGetOrganisationGroupUsers: async (orgGroupId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgGroupId' is not null or undefined
            if (orgGroupId === null || orgGroupId === undefined) {
                throw new RequiredError('orgGroupId','Required parameter orgGroupId was null or undefined when calling organisationGroupUsersGetOrganisationGroupUsers.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupUsersGetOrganisationGroupUsers.');
            }
            const localVarPath = `/OrganisationGroupUsers/GetOrganisationGroupUsers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgGroupId !== undefined) {
                localVarQueryParameter['orgGroupId'] = orgGroupId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the users who belong to an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetOrganisationGroupUsersRequest} request A request object specifying which users belong to an organisation group.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update. CsvUserIds is a comma separated list of User Ids, e.g. 1,2,3,4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupUsersUpdateOrganisationGroupUsers: async (xChronosheetsAuth: string, request: SetOrganisationGroupUsersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupUsersUpdateOrganisationGroupUsers.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling organisationGroupUsersUpdateOrganisationGroupUsers.');
            }
            const localVarPath = `/OrganisationGroupUsers/UpdateOrganisationGroupUsers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationGroupUsersApi - functional programming interface
 * @export
 */
export const OrganisationGroupUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a collection of organisation group users that belong to an organisation group.    Requires the \'ManageOrganisationGroups\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} orgGroupId An OrganisationGroup Id
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupUsersGetOrganisationGroupUsers(orgGroupId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListUserForManagement>> {
            const localVarAxiosArgs = await OrganisationGroupUsersApiAxiosParamCreator(configuration).organisationGroupUsersGetOrganisationGroupUsers(orgGroupId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set the users who belong to an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetOrganisationGroupUsersRequest} request A request object specifying which users belong to an organisation group.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update. CsvUserIds is a comma separated list of User Ids, e.g. 1,2,3,4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth: string, request: SetOrganisationGroupUsersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await OrganisationGroupUsersApiAxiosParamCreator(configuration).organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganisationGroupUsersApi - factory interface
 * @export
 */
export const OrganisationGroupUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a collection of organisation group users that belong to an organisation group.    Requires the \'ManageOrganisationGroups\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} orgGroupId An OrganisationGroup Id
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupUsersGetOrganisationGroupUsers(orgGroupId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListUserForManagement> {
            return OrganisationGroupUsersApiFp(configuration).organisationGroupUsersGetOrganisationGroupUsers(orgGroupId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the users who belong to an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetOrganisationGroupUsersRequest} request A request object specifying which users belong to an organisation group.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update. CsvUserIds is a comma separated list of User Ids, e.g. 1,2,3,4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth: string, request: SetOrganisationGroupUsersRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return OrganisationGroupUsersApiFp(configuration).organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationGroupUsersApi - object-oriented interface
 * @export
 * @class OrganisationGroupUsersApi
 * @extends {BaseAPI}
 */
export class OrganisationGroupUsersApi extends BaseAPI {
    /**
     * 
     * @summary Get a collection of organisation group users that belong to an organisation group.    Requires the \'ManageOrganisationGroups\' or \'ManageOrganisationUsers\' permissions.
     * @param {number} orgGroupId An OrganisationGroup Id
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupUsersApi
     */
    public organisationGroupUsersGetOrganisationGroupUsers(orgGroupId: number, xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupUsersApiFp(this.configuration).organisationGroupUsersGetOrganisationGroupUsers(orgGroupId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the users who belong to an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {SetOrganisationGroupUsersRequest} request A request object specifying which users belong to an organisation group.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update. CsvUserIds is a comma separated list of User Ids, e.g. 1,2,3,4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupUsersApi
     */
    public organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth: string, request: SetOrganisationGroupUsersRequest, options?: any) {
        return OrganisationGroupUsersApiFp(this.configuration).organisationGroupUsersUpdateOrganisationGroupUsers(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganisationGroupsApi - axios parameter creator
 * @export
 */
export const OrganisationGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertOrganisationGroupRequest} request An Insert OrganisationGroup Request object containing values for the new OrganisationGroup to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsCreateOrganisationGroup: async (xChronosheetsAuth: string, request: InsertOrganisationGroupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsCreateOrganisationGroup.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling organisationGroupsCreateOrganisationGroup.');
            }
            const localVarPath = `/OrganisationGroups/CreateOrganisationGroup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organisationGroupId 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsDeleteOrganisationGroup: async (organisationGroupId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationGroupId' is not null or undefined
            if (organisationGroupId === null || organisationGroupId === undefined) {
                throw new RequiredError('organisationGroupId','Required parameter organisationGroupId was null or undefined when calling organisationGroupsDeleteOrganisationGroup.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsDeleteOrganisationGroup.');
            }
            const localVarPath = `/OrganisationGroups/DeleteOrganisationGroup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organisationGroupId !== undefined) {
                localVarQueryParameter['OrganisationGroupId'] = organisationGroupId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular organisation group.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} organisationGroupId The ID of the OrganisationGroup you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroup: async (organisationGroupId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationGroupId' is not null or undefined
            if (organisationGroupId === null || organisationGroupId === undefined) {
                throw new RequiredError('organisationGroupId','Required parameter organisationGroupId was null or undefined when calling organisationGroupsGetOrganisationGroup.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsGetOrganisationGroup.');
            }
            const localVarPath = `/OrganisationGroups/GetOrganisationGroup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organisationGroupId !== undefined) {
                localVarQueryParameter['OrganisationGroupId'] = organisationGroupId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection of organisation groups that are under your organisation.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroups: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsGetOrganisationGroups.');
            }
            const localVarPath = `/OrganisationGroups/GetOrganisationGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get org groups for a particular job.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroupsForJob: async (jobId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling organisationGroupsGetOrganisationGroupsForJob.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsGetOrganisationGroupsForJob.');
            }
            const localVarPath = `/OrganisationGroups/GetOrganisationGroupsForJob`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                localVarQueryParameter['JobId'] = jobId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get org groups for a particular vehicle.    Requires the \'ManageOrganisationGroups\', \'ManageFleet\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} vehicleId The ID of the vehicle
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroupsForVehicle: async (vehicleId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            if (vehicleId === null || vehicleId === undefined) {
                throw new RequiredError('vehicleId','Required parameter vehicleId was null or undefined when calling organisationGroupsGetOrganisationGroupsForVehicle.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsGetOrganisationGroupsForVehicle.');
            }
            const localVarPath = `/OrganisationGroups/GetOrganisationGroupsForVehicle`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['VehicleId'] = vehicleId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveOrganisationGroupRequest} request A Save OrganisationGroup Request object containing updated fields.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsUpdateOrganisationGroup: async (xChronosheetsAuth: string, request: SaveOrganisationGroupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling organisationGroupsUpdateOrganisationGroup.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling organisationGroupsUpdateOrganisationGroup.');
            }
            const localVarPath = `/OrganisationGroups/UpdateOrganisationGroup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationGroupsApi - functional programming interface
 * @export
 */
export const OrganisationGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertOrganisationGroupRequest} request An Insert OrganisationGroup Request object containing values for the new OrganisationGroup to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsCreateOrganisationGroup(xChronosheetsAuth: string, request: InsertOrganisationGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsCreateOrganisationGroup(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} organisationGroupId 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsDeleteOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsDeleteOrganisationGroup(organisationGroupId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular organisation group.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} organisationGroupId The ID of the OrganisationGroup you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsGetOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOrganisationGroup>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsGetOrganisationGroup(organisationGroupId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a collection of organisation groups that are under your organisation.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsGetOrganisationGroups(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListOrganisationGroup>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsGetOrganisationGroups(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get org groups for a particular job.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsGetOrganisationGroupsForJob(jobId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListOrganisationGroup>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsGetOrganisationGroupsForJob(jobId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get org groups for a particular vehicle.    Requires the \'ManageOrganisationGroups\', \'ManageFleet\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} vehicleId The ID of the vehicle
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsGetOrganisationGroupsForVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListOrganisationGroup>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsGetOrganisationGroupsForVehicle(vehicleId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveOrganisationGroupRequest} request A Save OrganisationGroup Request object containing updated fields.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth: string, request: SaveOrganisationGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await OrganisationGroupsApiAxiosParamCreator(configuration).organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganisationGroupsApi - factory interface
 * @export
 */
export const OrganisationGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertOrganisationGroupRequest} request An Insert OrganisationGroup Request object containing values for the new OrganisationGroup to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsCreateOrganisationGroup(xChronosheetsAuth: string, request: InsertOrganisationGroupRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsCreateOrganisationGroup(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} organisationGroupId 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsDeleteOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsDeleteOrganisationGroup(organisationGroupId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular organisation group.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} organisationGroupId The ID of the OrganisationGroup you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseOrganisationGroup> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsGetOrganisationGroup(organisationGroupId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a collection of organisation groups that are under your organisation.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroups(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListOrganisationGroup> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsGetOrganisationGroups(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get org groups for a particular job.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroupsForJob(jobId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListOrganisationGroup> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsGetOrganisationGroupsForJob(jobId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get org groups for a particular vehicle.    Requires the \'ManageOrganisationGroups\', \'ManageFleet\' or \'ManageOrganisationUsers\' permissions.
         * @param {number} vehicleId The ID of the vehicle
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsGetOrganisationGroupsForVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListOrganisationGroup> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsGetOrganisationGroupsForVehicle(vehicleId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SaveOrganisationGroupRequest} request A Save OrganisationGroup Request object containing updated fields.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth: string, request: SaveOrganisationGroupRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return OrganisationGroupsApiFp(configuration).organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationGroupsApi - object-oriented interface
 * @export
 * @class OrganisationGroupsApi
 * @extends {BaseAPI}
 */
export class OrganisationGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertOrganisationGroupRequest} request An Insert OrganisationGroup Request object containing values for the new OrganisationGroup to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsCreateOrganisationGroup(xChronosheetsAuth: string, request: InsertOrganisationGroupRequest, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsCreateOrganisationGroup(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} organisationGroupId 
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsDeleteOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsDeleteOrganisationGroup(organisationGroupId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular organisation group.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
     * @param {number} organisationGroupId The ID of the OrganisationGroup you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsGetOrganisationGroup(organisationGroupId: number, xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsGetOrganisationGroup(organisationGroupId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a collection of organisation groups that are under your organisation.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsGetOrganisationGroups(xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsGetOrganisationGroups(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get org groups for a particular job.    Requires the \'ManageOrganisationGroups\', \'ManageJobsAndTask\', \'ManageClientsAndProjects\' or \'ManageOrganisationUsers\' permissions.
     * @param {number} jobId The ID of the job
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsGetOrganisationGroupsForJob(jobId: number, xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsGetOrganisationGroupsForJob(jobId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get org groups for a particular vehicle.    Requires the \'ManageOrganisationGroups\', \'ManageFleet\' or \'ManageOrganisationUsers\' permissions.
     * @param {number} vehicleId The ID of the vehicle
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsGetOrganisationGroupsForVehicle(vehicleId: number, xChronosheetsAuth: string, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsGetOrganisationGroupsForVehicle(vehicleId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an organisation group.    Requires the \'ManageOrganisationGroups\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {SaveOrganisationGroupRequest} request A Save OrganisationGroup Request object containing updated fields.  Make sure to specify the OrganisationGroup Id in the request object so that ChronoSheets knows which OrganisationGroup to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationGroupsApi
     */
    public organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth: string, request: SaveOrganisationGroupRequest, options?: any) {
        return OrganisationGroupsApiFp(this.configuration).organisationGroupsUpdateOrganisationGroup(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertProjectRequest} request An Insert Project Request object containing values for the new Project to create.  Make sure to specify a correct Client Id - this will be used to attach the new project under that client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreateProject: async (xChronosheetsAuth: string, request: InsertProjectRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling projectsCreateProject.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling projectsCreateProject.');
            }
            const localVarPath = `/Projects/CreateProject`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a project by its Id.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} projectId The ID of the Project you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectById: async (projectId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling projectsGetProjectById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling projectsGetProjectById.');
            }
            const localVarPath = `/Projects/GetProjectById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['ProjectId'] = projectId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects for a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the client
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectsForClient: async (clientId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling projectsGetProjectsForClient.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling projectsGetProjectsForClient.');
            }
            const localVarPath = `/Projects/GetProjectsForClient`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['ClientId'] = clientId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateProjectRequest} request An Update Project Request object containing updated fields.  Make sure to specify the Project Id in the request object so that ChronoSheets knows which Project to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdateProject: async (xChronosheetsAuth: string, request: UpdateProjectRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling projectsUpdateProject.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling projectsUpdateProject.');
            }
            const localVarPath = `/Projects/UpdateProject`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertProjectRequest} request An Insert Project Request object containing values for the new Project to create.  Make sure to specify a correct Client Id - this will be used to attach the new project under that client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreateProject(xChronosheetsAuth: string, request: InsertProjectRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).projectsCreateProject(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a project by its Id.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} projectId The ID of the Project you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetProjectById(projectId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseProject>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).projectsGetProjectById(projectId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get projects for a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the client
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetProjectsForClient(clientId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListProject>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).projectsGetProjectsForClient(clientId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateProjectRequest} request An Update Project Request object containing updated fields.  Make sure to specify the Project Id in the request object so that ChronoSheets knows which Project to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdateProject(xChronosheetsAuth: string, request: UpdateProjectRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).projectsUpdateProject(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertProjectRequest} request An Insert Project Request object containing values for the new Project to create.  Make sure to specify a correct Client Id - this will be used to attach the new project under that client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreateProject(xChronosheetsAuth: string, request: InsertProjectRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return ProjectsApiFp(configuration).projectsCreateProject(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a project by its Id.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} projectId The ID of the Project you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectById(projectId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseProject> {
            return ProjectsApiFp(configuration).projectsGetProjectById(projectId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects for a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
         * @param {number} clientId The ID of the client
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectsForClient(clientId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListProject> {
            return ProjectsApiFp(configuration).projectsGetProjectsForClient(clientId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a project.    Requires the \'ManageClientsAndProjects\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateProjectRequest} request An Update Project Request object containing updated fields.  Make sure to specify the Project Id in the request object so that ChronoSheets knows which Project to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdateProject(xChronosheetsAuth: string, request: UpdateProjectRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return ProjectsApiFp(configuration).projectsUpdateProject(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a project.    Requires the \'ManageClientsAndProjects\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertProjectRequest} request An Insert Project Request object containing values for the new Project to create.  Make sure to specify a correct Client Id - this will be used to attach the new project under that client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsCreateProject(xChronosheetsAuth: string, request: InsertProjectRequest, options?: any) {
        return ProjectsApiFp(this.configuration).projectsCreateProject(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a project by its Id.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
     * @param {number} projectId The ID of the Project you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsGetProjectById(projectId: number, xChronosheetsAuth: string, options?: any) {
        return ProjectsApiFp(this.configuration).projectsGetProjectById(projectId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects for a particular client.    Requires the \'ManageClientsAndProjects\' or \'ManageJobsAndTask\' permissions.
     * @param {number} clientId The ID of the client
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsGetProjectsForClient(clientId: number, xChronosheetsAuth: string, options?: any) {
        return ProjectsApiFp(this.configuration).projectsGetProjectsForClient(clientId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a project.    Requires the \'ManageClientsAndProjects\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateProjectRequest} request An Update Project Request object containing updated fields.  Make sure to specify the Project Id in the request object so that ChronoSheets knows which Project to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsUpdateProject(xChronosheetsAuth: string, request: UpdateProjectRequest, options?: any) {
        return ProjectsApiFp(this.configuration).projectsUpdateProject(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Consolidated Admin Reports Data (Jobs, Tasks, Clients and Projects).  These are the organisation wide reports, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks'} [forceOnlyThisChart] A flag to indicate which report data you require.  Choose a particular set of data, or if you want all data use the \&#39;NotForced\&#39; option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetAllChartsDataAdmin: async (startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, forceOnlyThisChart?: 'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetAllChartsDataAdmin.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetAllChartsDataAdmin.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetAllChartsDataAdmin.');
            }
            const localVarPath = `/Reports/GetAllChartsDataAdmin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (forceOnlyThisChart !== undefined) {
                localVarQueryParameter['ForceOnlyThisChart'] = forceOnlyThisChart;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Consolidated User Reports Data (Jobs, Tasks, Clients and Projects).  These are the user\'s own reports.    Requires the \'ViewOwnReports\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetAllChartsDataUser: async (startDate: string, endDate: string, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetAllChartsDataUser.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetAllChartsDataUser.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetAllChartsDataUser.');
            }
            const localVarPath = `/Reports/GetAllChartsDataUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a summary report, which includes total distance travelled and total running costs, for vehicles within your organisation  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetFleetSummaryAdmin: async (startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetFleetSummaryAdmin.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetFleetSummaryAdmin.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetFleetSummaryAdmin.');
            }
            const localVarPath = `/Reports/GetFleetSummaryAdmin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trip by Id, for reporting purposes.    Requires the \'ReportAdmin\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrgTripById: async (tripId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            if (tripId === null || tripId === undefined) {
                throw new RequiredError('tripId','Required parameter tripId was null or undefined when calling reportsGetOrgTripById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetOrgTripById.');
            }
            const localVarPath = `/Reports/GetOrgTripById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tripId !== undefined) {
                localVarQueryParameter['TripId'] = tripId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports on Organisation timesheet file attachments (files uploaded and attached to timesheet records)  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTimesheetFileAttachments: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetOrganisationTimesheetFileAttachments.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetOrganisationTimesheetFileAttachments.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetOrganisationTimesheetFileAttachments.');
            }
            const localVarPath = `/Reports/GetOrganisationTimesheetFileAttachments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports on Organisation transcripts (When an audio file is attached, it will be automatically transcribed, these are the transcriptions)    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {string} [keywords] Search the transcripts by keyword(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTranscripts: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetOrganisationTranscripts.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetOrganisationTranscripts.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetOrganisationTranscripts.');
            }
            const localVarPath = `/Reports/GetOrganisationTranscripts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['Keywords'] = keywords;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports on Organisation trips (GPS tracking from whole organisation).    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTrips: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetOrganisationTrips.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetOrganisationTrips.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetOrganisationTrips.');
            }
            const localVarPath = `/Reports/GetOrganisationTrips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Timesheets Raw Data.  This data details each timesheet record.  These are the organisation wide timesheet records, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username'} [sort] Decide which column to sort on
         * @param {'Ascending' | 'Descending'} [order] Decide which direction to sort the column
         * @param {number} [skip] Skip this many rows
         * @param {number} [take] Take this many rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetRawDataAdmin: async (startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, sort?: 'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username', order?: 'Ascending' | 'Descending', skip?: number, take?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsGetRawDataAdmin.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsGetRawDataAdmin.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsGetRawDataAdmin.');
            }
            const localVarPath = `/Reports/GetRawDataAdmin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (sort !== undefined) {
                localVarQueryParameter['Sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['Order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets project cost estimations VS actual cost for date range and users.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProjectCostingsAdmin: async (startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsProjectCostingsAdmin.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsProjectCostingsAdmin.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsProjectCostingsAdmin.');
            }
            const localVarPath = `/Reports/ProjectCostingsAdmin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Timeseries jobs data for the logged in user.    Requires the \'ViewOwnReports\' or \'SubmitTimesheets\'.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsUserJobsOverTime: async (startDate: string, endDate: string, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportsUserJobsOverTime.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportsUserJobsOverTime.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling reportsUserJobsOverTime.');
            }
            const localVarPath = `/Reports/UserJobsOverTime`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Consolidated Admin Reports Data (Jobs, Tasks, Clients and Projects).  These are the organisation wide reports, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks'} [forceOnlyThisChart] A flag to indicate which report data you require.  Choose a particular set of data, or if you want all data use the \&#39;NotForced\&#39; option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetAllChartsDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, forceOnlyThisChart?: 'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseCombinedReportsData>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetAllChartsDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, forceOnlyThisChart, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Consolidated User Reports Data (Jobs, Tasks, Clients and Projects).  These are the user\'s own reports.    Requires the \'ViewOwnReports\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetAllChartsDataUser(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseCombinedReportsData>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetAllChartsDataUser(startDate, endDate, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a summary report, which includes total distance travelled and total running costs, for vehicles within your organisation  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetFleetSummaryAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListFleetSummaryReportItem>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetFleetSummaryAdmin(startDate, endDate, xChronosheetsAuth, userIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get trip by Id, for reporting purposes.    Requires the \'ReportAdmin\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetOrgTripById(tripId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTrip>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetOrgTripById(tripId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports on Organisation timesheet file attachments (files uploaded and attached to timesheet records)  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetOrganisationTimesheetFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListOrgReportTimesheetFileAttachment>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetOrganisationTimesheetFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports on Organisation transcripts (When an audio file is attached, it will be automatically transcribed, these are the transcriptions)    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {string} [keywords] Search the transcripts by keyword(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetOrganisationTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListOrgReportTranscript>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetOrganisationTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, userIds, keywords, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports on Organisation trips (GPS tracking from whole organisation).    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetOrganisationTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListOrgReportTrip>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetOrganisationTrips(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Timesheets Raw Data.  This data details each timesheet record.  These are the organisation wide timesheet records, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username'} [sort] Decide which column to sort on
         * @param {'Ascending' | 'Descending'} [order] Decide which direction to sort the column
         * @param {number} [skip] Skip this many rows
         * @param {number} [take] Take this many rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGetRawDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, sort?: 'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username', order?: 'Ascending' | 'Descending', skip?: number, take?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListRawReportItem>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsGetRawDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, sort, order, skip, take, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets project cost estimations VS actual cost for date range and users.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProjectCostingsAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListProjectCostingReportItem>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsProjectCostingsAdmin(startDate, endDate, xChronosheetsAuth, userIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Timeseries jobs data for the logged in user.    Requires the \'ViewOwnReports\' or \'SubmitTimesheets\'.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsUserJobsOverTime(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListJobSeriesReportItem>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).reportsUserJobsOverTime(startDate, endDate, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Consolidated Admin Reports Data (Jobs, Tasks, Clients and Projects).  These are the organisation wide reports, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks'} [forceOnlyThisChart] A flag to indicate which report data you require.  Choose a particular set of data, or if you want all data use the \&#39;NotForced\&#39; option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetAllChartsDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, forceOnlyThisChart?: 'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks', options?: any): AxiosPromise<ApiResponseCombinedReportsData> {
            return ReportsApiFp(configuration).reportsGetAllChartsDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, forceOnlyThisChart, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Consolidated User Reports Data (Jobs, Tasks, Clients and Projects).  These are the user\'s own reports.    Requires the \'ViewOwnReports\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetAllChartsDataUser(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseCombinedReportsData> {
            return ReportsApiFp(configuration).reportsGetAllChartsDataUser(startDate, endDate, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a summary report, which includes total distance travelled and total running costs, for vehicles within your organisation  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetFleetSummaryAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any): AxiosPromise<ApiResponseListFleetSummaryReportItem> {
            return ReportsApiFp(configuration).reportsGetFleetSummaryAdmin(startDate, endDate, xChronosheetsAuth, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trip by Id, for reporting purposes.    Requires the \'ReportAdmin\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrgTripById(tripId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseTrip> {
            return ReportsApiFp(configuration).reportsGetOrgTripById(tripId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports on Organisation timesheet file attachments (files uploaded and attached to timesheet records)  Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTimesheetFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any): AxiosPromise<ApiResponseForPaginatedListOrgReportTimesheetFileAttachment> {
            return ReportsApiFp(configuration).reportsGetOrganisationTimesheetFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports on Organisation transcripts (When an audio file is attached, it will be automatically transcribed, these are the transcriptions)    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {string} [keywords] Search the transcripts by keyword(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, keywords?: string, options?: any): AxiosPromise<ApiResponseForPaginatedListOrgReportTranscript> {
            return ReportsApiFp(configuration).reportsGetOrganisationTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, userIds, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports on Organisation trips (GPS tracking from whole organisation).    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many items
         * @param {number} [take] Take this many items
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetOrganisationTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any): AxiosPromise<ApiResponseForPaginatedListOrgReportTrip> {
            return ReportsApiFp(configuration).reportsGetOrganisationTrips(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Timesheets Raw Data.  This data details each timesheet record.  These are the organisation wide timesheet records, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username'} [sort] Decide which column to sort on
         * @param {'Ascending' | 'Descending'} [order] Decide which direction to sort the column
         * @param {number} [skip] Skip this many rows
         * @param {number} [take] Take this many rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGetRawDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, sort?: 'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username', order?: 'Ascending' | 'Descending', skip?: number, take?: number, options?: any): AxiosPromise<ApiResponseForPaginatedListRawReportItem> {
            return ReportsApiFp(configuration).reportsGetRawDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, sort, order, skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets project cost estimations VS actual cost for date range and users.    Requires the \'ReportAdmin\' permission.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProjectCostingsAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any): AxiosPromise<ApiResponseListProjectCostingReportItem> {
            return ReportsApiFp(configuration).reportsProjectCostingsAdmin(startDate, endDate, xChronosheetsAuth, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Timeseries jobs data for the logged in user.    Requires the \'ViewOwnReports\' or \'SubmitTimesheets\'.
         * @param {string} startDate The start date for the date range.  Report data in the response is after this date
         * @param {string} endDate The end date for the date range.  Report data in the response is before this date
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsUserJobsOverTime(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListJobSeriesReportItem> {
            return ReportsApiFp(configuration).reportsUserJobsOverTime(startDate, endDate, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Get Consolidated Admin Reports Data (Jobs, Tasks, Clients and Projects).  These are the organisation wide reports, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks'} [forceOnlyThisChart] A flag to indicate which report data you require.  Choose a particular set of data, or if you want all data use the \&#39;NotForced\&#39; option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetAllChartsDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, forceOnlyThisChart?: 'NotForced' | 'SeriesJobCodes' | 'SeriesClients' | 'SeriesProjects' | 'SeriesTasks' | 'TotalsClients' | 'TotalsJobCodes' | 'TotalsProjects' | 'TotalsTasks', options?: any) {
        return ReportsApiFp(this.configuration).reportsGetAllChartsDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, forceOnlyThisChart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Consolidated User Reports Data (Jobs, Tasks, Clients and Projects).  These are the user\'s own reports.    Requires the \'ViewOwnReports\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetAllChartsDataUser(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetAllChartsDataUser(startDate, endDate, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a summary report, which includes total distance travelled and total running costs, for vehicles within your organisation  Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetFleetSummaryAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetFleetSummaryAdmin(startDate, endDate, xChronosheetsAuth, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trip by Id, for reporting purposes.    Requires the \'ReportAdmin\' permission.
     * @param {number} tripId The ID of the Trip you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetOrgTripById(tripId: number, xChronosheetsAuth: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetOrgTripById(tripId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports on Organisation timesheet file attachments (files uploaded and attached to timesheet records)  Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many items
     * @param {number} [take] Take this many items
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetOrganisationTimesheetFileAttachments(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetOrganisationTimesheetFileAttachments(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports on Organisation transcripts (When an audio file is attached, it will be automatically transcribed, these are the transcriptions)    Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many items
     * @param {number} [take] Take this many items
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {string} [keywords] Search the transcripts by keyword(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetOrganisationTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, keywords?: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetOrganisationTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, userIds, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports on Organisation trips (GPS tracking from whole organisation).    Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many items
     * @param {number} [take] Take this many items
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetOrganisationTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, userIds?: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetOrganisationTrips(startDate, endDate, xChronosheetsAuth, skip, take, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Timesheets Raw Data.  This data details each timesheet record.  These are the organisation wide timesheet records, with data from potentially all employees.    Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username'} [sort] Decide which column to sort on
     * @param {'Ascending' | 'Descending'} [order] Decide which direction to sort the column
     * @param {number} [skip] Skip this many rows
     * @param {number} [take] Take this many rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGetRawDataAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, sort?: 'EmailAddress' | 'JobCode' | 'TaskName' | 'ClientName' | 'ProjectName' | 'StartDate' | 'EndDate' | 'SpanSeconds' | 'Description' | 'PayAmount' | 'PayOvertimeAmount' | 'TripCost' | 'TripDistanceMeters' | 'Username', order?: 'Ascending' | 'Descending', skip?: number, take?: number, options?: any) {
        return ReportsApiFp(this.configuration).reportsGetRawDataAdmin(startDate, endDate, xChronosheetsAuth, userIds, sort, order, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets project cost estimations VS actual cost for date range and users.    Requires the \'ReportAdmin\' permission.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {string} [userIds] A comma-separated list of user Ids, if you want to filter the report data to particular users.  If you want all, send a blank string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsProjectCostingsAdmin(startDate: string, endDate: string, xChronosheetsAuth: string, userIds?: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsProjectCostingsAdmin(startDate, endDate, xChronosheetsAuth, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Timeseries jobs data for the logged in user.    Requires the \'ViewOwnReports\' or \'SubmitTimesheets\'.
     * @param {string} startDate The start date for the date range.  Report data in the response is after this date
     * @param {string} endDate The end date for the date range.  Report data in the response is before this date
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsUserJobsOverTime(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any) {
        return ReportsApiFp(this.configuration).reportsUserJobsOverTime(startDate, endDate, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertTaskRequest} request An Insert Task Request object containing values for the new Task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateTask: async (xChronosheetsAuth: string, request: InsertTaskRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksCreateTask.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling tasksCreateTask.');
            }
            const localVarPath = `/Tasks/CreateTask`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} taskId The ID of the Task you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDeleteTask: async (taskId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling tasksDeleteTask.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksDeleteTask.');
            }
            const localVarPath = `/Tasks/DeleteTask`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['TaskId'] = taskId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular task by Id.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} taskId The ID of the TimesheetTask you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTaskById: async (taskId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling tasksGetTaskById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksGetTaskById.');
            }
            const localVarPath = `/Tasks/GetTaskById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['TaskId'] = taskId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tasks in your organisation.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTasks: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksGetTasks.');
            }
            const localVarPath = `/Tasks/GetTasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection of tasks for a particular Job, specified by JobId.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTasksForJob: async (jobId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling tasksGetTasksForJob.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksGetTasksForJob.');
            }
            const localVarPath = `/Tasks/GetTasksForJob`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                localVarQueryParameter['JobId'] = jobId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateTaskRequest} request An Update Task Request object containing updated fields.  Make sure to specify the Task Id in the request object so that ChronoSheets knows which Task to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateTask: async (xChronosheetsAuth: string, request: UpdateTaskRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tasksUpdateTask.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling tasksUpdateTask.');
            }
            const localVarPath = `/Tasks/UpdateTask`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertTaskRequest} request An Insert Task Request object containing values for the new Task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateTask(xChronosheetsAuth: string, request: InsertTaskRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksCreateTask(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} taskId The ID of the Task you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDeleteTask(taskId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksDeleteTask(taskId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular task by Id.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} taskId The ID of the TimesheetTask you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksGetTaskById(taskId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTimesheetTask>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksGetTaskById(taskId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get tasks in your organisation.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksGetTasks(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListTimesheetTask>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksGetTasks(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a collection of tasks for a particular Job, specified by JobId.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksGetTasksForJob(jobId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListTimesheetTask>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksGetTasksForJob(jobId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateTaskRequest} request An Update Task Request object containing updated fields.  Make sure to specify the Task Id in the request object so that ChronoSheets knows which Task to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksUpdateTask(xChronosheetsAuth: string, request: UpdateTaskRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksUpdateTask(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertTaskRequest} request An Insert Task Request object containing values for the new Task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateTask(xChronosheetsAuth: string, request: InsertTaskRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return TasksApiFp(configuration).tasksCreateTask(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {number} taskId The ID of the Task you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDeleteTask(taskId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return TasksApiFp(configuration).tasksDeleteTask(taskId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular task by Id.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} taskId The ID of the TimesheetTask you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTaskById(taskId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseTimesheetTask> {
            return TasksApiFp(configuration).tasksGetTaskById(taskId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tasks in your organisation.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTasks(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListTimesheetTask> {
            return TasksApiFp(configuration).tasksGetTasks(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a collection of tasks for a particular Job, specified by JobId.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
         * @param {number} jobId The ID of the job
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGetTasksForJob(jobId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListTimesheetTask> {
            return TasksApiFp(configuration).tasksGetTasksForJob(jobId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a task.    Requires the \'ManageJobsAndTask\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateTaskRequest} request An Update Task Request object containing updated fields.  Make sure to specify the Task Id in the request object so that ChronoSheets knows which Task to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateTask(xChronosheetsAuth: string, request: UpdateTaskRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return TasksApiFp(configuration).tasksUpdateTask(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Create a task.    Requires the \'ManageJobsAndTask\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertTaskRequest} request An Insert Task Request object containing values for the new Task to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateTask(xChronosheetsAuth: string, request: InsertTaskRequest, options?: any) {
        return TasksApiFp(this.configuration).tasksCreateTask(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a task.    Requires the \'ManageJobsAndTask\' permission.
     * @param {number} taskId The ID of the Task you want to delete
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDeleteTask(taskId: number, xChronosheetsAuth: string, options?: any) {
        return TasksApiFp(this.configuration).tasksDeleteTask(taskId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular task by Id.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
     * @param {number} taskId The ID of the TimesheetTask you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGetTaskById(taskId: number, xChronosheetsAuth: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGetTaskById(taskId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tasks in your organisation.   Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGetTasks(xChronosheetsAuth: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGetTasks(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a collection of tasks for a particular Job, specified by JobId.    Requires the \'SubmitTimesheets\' or \'ManageJobsAndTask\' permissions.
     * @param {number} jobId The ID of the job
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGetTasksForJob(jobId: number, xChronosheetsAuth: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGetTasksForJob(jobId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a task.    Requires the \'ManageJobsAndTask\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateTaskRequest} request An Update Task Request object containing updated fields.  Make sure to specify the Task Id in the request object so that ChronoSheets knows which Task to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksUpdateTask(xChronosheetsAuth: string, request: UpdateTaskRequest, options?: any) {
        return TasksApiFp(this.configuration).tasksUpdateTask(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TimesheetAutomationApi - axios parameter creator
 * @export
 */
export const TimesheetAutomationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an automation step.  Timesheet automation is determined by looking at steps taken by the user.  Create a step to log some automation action, such as entering a geofence or tapping on an NFC badge.  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateAutomationStepRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetAutomationCreateAutomationStep: async (xChronosheetsAuth: string, request: CreateAutomationStepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetAutomationCreateAutomationStep.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling timesheetAutomationCreateAutomationStep.');
            }
            const localVarPath = `/TimesheetAutomation/CreateAutomationStep`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the timesheet automation / alerts for geofences activities or NFC tap on/off.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId The ID of the Geofence
         * @param {number} nfcId 
         * @param {number} userId 
         * @param {'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed'} sort 
         * @param {'Ascending' | 'Descending'} order 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many records
         * @param {number} [take] Take this many records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetAutomationGetTimesheetAutomationAuditTrail: async (geofenceId: number, nfcId: number, userId: number, sort: 'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed', order: 'Ascending' | 'Descending', xChronosheetsAuth: string, skip?: number, take?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'geofenceId' is not null or undefined
            if (geofenceId === null || geofenceId === undefined) {
                throw new RequiredError('geofenceId','Required parameter geofenceId was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            // verify required parameter 'nfcId' is not null or undefined
            if (nfcId === null || nfcId === undefined) {
                throw new RequiredError('nfcId','Required parameter nfcId was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetAutomationGetTimesheetAutomationAuditTrail.');
            }
            const localVarPath = `/TimesheetAutomation/GetTimesheetAutomationAuditTrail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (geofenceId !== undefined) {
                localVarQueryParameter['GeofenceId'] = geofenceId;
            }

            if (nfcId !== undefined) {
                localVarQueryParameter['NfcId'] = nfcId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['Sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['Order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheetAutomationApi - functional programming interface
 * @export
 */
export const TimesheetAutomationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an automation step.  Timesheet automation is determined by looking at steps taken by the user.  Create a step to log some automation action, such as entering a geofence or tapping on an NFC badge.  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateAutomationStepRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetAutomationCreateAutomationStep(xChronosheetsAuth: string, request: CreateAutomationStepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await TimesheetAutomationApiAxiosParamCreator(configuration).timesheetAutomationCreateAutomationStep(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the timesheet automation / alerts for geofences activities or NFC tap on/off.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId The ID of the Geofence
         * @param {number} nfcId 
         * @param {number} userId 
         * @param {'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed'} sort 
         * @param {'Ascending' | 'Descending'} order 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many records
         * @param {number} [take] Take this many records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId: number, nfcId: number, userId: number, sort: 'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed', order: 'Ascending' | 'Descending', xChronosheetsAuth: string, skip?: number, take?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence>> {
            const localVarAxiosArgs = await TimesheetAutomationApiAxiosParamCreator(configuration).timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId, nfcId, userId, sort, order, xChronosheetsAuth, skip, take, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimesheetAutomationApi - factory interface
 * @export
 */
export const TimesheetAutomationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates an automation step.  Timesheet automation is determined by looking at steps taken by the user.  Create a step to log some automation action, such as entering a geofence or tapping on an NFC badge.  Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateAutomationStepRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetAutomationCreateAutomationStep(xChronosheetsAuth: string, request: CreateAutomationStepRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return TimesheetAutomationApiFp(configuration).timesheetAutomationCreateAutomationStep(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the timesheet automation / alerts for geofences activities or NFC tap on/off.  Requires the \'ManageGeofencing\' permission.
         * @param {number} geofenceId The ID of the Geofence
         * @param {number} nfcId 
         * @param {number} userId 
         * @param {'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed'} sort 
         * @param {'Ascending' | 'Descending'} order 
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many records
         * @param {number} [take] Take this many records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId: number, nfcId: number, userId: number, sort: 'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed', order: 'Ascending' | 'Descending', xChronosheetsAuth: string, skip?: number, take?: number, options?: any): AxiosPromise<ApiResponseForPaginatedListTimesheetAutomationWithOrgAndGeofence> {
            return TimesheetAutomationApiFp(configuration).timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId, nfcId, userId, sort, order, xChronosheetsAuth, skip, take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimesheetAutomationApi - object-oriented interface
 * @export
 * @class TimesheetAutomationApi
 * @extends {BaseAPI}
 */
export class TimesheetAutomationApi extends BaseAPI {
    /**
     * 
     * @summary Creates an automation step.  Timesheet automation is determined by looking at steps taken by the user.  Create a step to log some automation action, such as entering a geofence or tapping on an NFC badge.  Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {CreateAutomationStepRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetAutomationApi
     */
    public timesheetAutomationCreateAutomationStep(xChronosheetsAuth: string, request: CreateAutomationStepRequest, options?: any) {
        return TimesheetAutomationApiFp(this.configuration).timesheetAutomationCreateAutomationStep(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the timesheet automation / alerts for geofences activities or NFC tap on/off.  Requires the \'ManageGeofencing\' permission.
     * @param {number} geofenceId The ID of the Geofence
     * @param {number} nfcId 
     * @param {number} userId 
     * @param {'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed'} sort 
     * @param {'Ascending' | 'Descending'} order 
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many records
     * @param {number} [take] Take this many records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetAutomationApi
     */
    public timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId: number, nfcId: number, userId: number, sort: 'UserName' | 'AutomationActionType' | 'ClientDateTime' | 'IsProcessed', order: 'Ascending' | 'Descending', xChronosheetsAuth: string, skip?: number, take?: number, options?: any) {
        return TimesheetAutomationApiFp(this.configuration).timesheetAutomationGetTimesheetAutomationAuditTrail(geofenceId, nfcId, userId, sort, order, xChronosheetsAuth, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TimesheetsApi - axios parameter creator
 * @export
 */
export const TimesheetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Inserts a single timesheet record.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {Timesheet} request A Timesheet Request object containing values for the new Timesheet to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsCreateSingleTimesheet: async (xChronosheetsAuth: string, request: Timesheet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetsCreateSingleTimesheet.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling timesheetsCreateSingleTimesheet.');
            }
            const localVarPath = `/Timesheets/CreateSingleTimesheet`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a timesheet.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} timesheetId The ID of the Timesheet you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsDeleteTimesheet: async (timesheetId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timesheetId' is not null or undefined
            if (timesheetId === null || timesheetId === undefined) {
                throw new RequiredError('timesheetId','Required parameter timesheetId was null or undefined when calling timesheetsDeleteTimesheet.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetsDeleteTimesheet.');
            }
            const localVarPath = `/Timesheets/DeleteTimesheet`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timesheetId !== undefined) {
                localVarQueryParameter['TimesheetId'] = timesheetId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} startDate The start date of the date range
         * @param {string} endDate The end date of the date range
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsGetTimesheets: async (startDate: string, endDate: string, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling timesheetsGetTimesheets.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling timesheetsGetTimesheets.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetsGetTimesheets.');
            }
            const localVarPath = `/Timesheets/GetTimesheets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch update timesheets.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {BatchUpdateTimesheetRequest} request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsUpdateTimesheets: async (xChronosheetsAuth: string, request: BatchUpdateTimesheetRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling timesheetsUpdateTimesheets.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling timesheetsUpdateTimesheets.');
            }
            const localVarPath = `/Timesheets/UpdateTimesheets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheetsApi - functional programming interface
 * @export
 */
export const TimesheetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Inserts a single timesheet record.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {Timesheet} request A Timesheet Request object containing values for the new Timesheet to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsCreateSingleTimesheet(xChronosheetsAuth: string, request: Timesheet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await TimesheetsApiAxiosParamCreator(configuration).timesheetsCreateSingleTimesheet(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a timesheet.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} timesheetId The ID of the Timesheet you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsDeleteTimesheet(timesheetId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await TimesheetsApiAxiosParamCreator(configuration).timesheetsDeleteTimesheet(timesheetId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} startDate The start date of the date range
         * @param {string} endDate The end date of the date range
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsGetTimesheets(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListTimesheet>> {
            const localVarAxiosArgs = await TimesheetsApiAxiosParamCreator(configuration).timesheetsGetTimesheets(startDate, endDate, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Batch update timesheets.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {BatchUpdateTimesheetRequest} request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsUpdateTimesheets(xChronosheetsAuth: string, request: BatchUpdateTimesheetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListInt32>> {
            const localVarAxiosArgs = await TimesheetsApiAxiosParamCreator(configuration).timesheetsUpdateTimesheets(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimesheetsApi - factory interface
 * @export
 */
export const TimesheetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Inserts a single timesheet record.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {Timesheet} request A Timesheet Request object containing values for the new Timesheet to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsCreateSingleTimesheet(xChronosheetsAuth: string, request: Timesheet, options?: any): AxiosPromise<ApiResponseInt32> {
            return TimesheetsApiFp(configuration).timesheetsCreateSingleTimesheet(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a timesheet.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} timesheetId The ID of the Timesheet you want to delete
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsDeleteTimesheet(timesheetId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return TimesheetsApiFp(configuration).timesheetsDeleteTimesheet(timesheetId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} startDate The start date of the date range
         * @param {string} endDate The end date of the date range
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsGetTimesheets(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListTimesheet> {
            return TimesheetsApiFp(configuration).timesheetsGetTimesheets(startDate, endDate, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch update timesheets.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {BatchUpdateTimesheetRequest} request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsUpdateTimesheets(xChronosheetsAuth: string, request: BatchUpdateTimesheetRequest, options?: any): AxiosPromise<ApiResponseListInt32> {
            return TimesheetsApiFp(configuration).timesheetsUpdateTimesheets(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimesheetsApi - object-oriented interface
 * @export
 * @class TimesheetsApi
 * @extends {BaseAPI}
 */
export class TimesheetsApi extends BaseAPI {
    /**
     * 
     * @summary Inserts a single timesheet record.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {Timesheet} request A Timesheet Request object containing values for the new Timesheet to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsCreateSingleTimesheet(xChronosheetsAuth: string, request: Timesheet, options?: any) {
        return TimesheetsApiFp(this.configuration).timesheetsCreateSingleTimesheet(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a timesheet.    Requires the \'SubmitTimesheets\' permission.
     * @param {number} timesheetId The ID of the Timesheet you want to delete
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsDeleteTimesheet(timesheetId: number, xChronosheetsAuth: string, options?: any) {
        return TimesheetsApiFp(this.configuration).timesheetsDeleteTimesheet(timesheetId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} startDate The start date of the date range
     * @param {string} endDate The end date of the date range
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsGetTimesheets(startDate: string, endDate: string, xChronosheetsAuth: string, options?: any) {
        return TimesheetsApiFp(this.configuration).timesheetsGetTimesheets(startDate, endDate, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch update timesheets.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {BatchUpdateTimesheetRequest} request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsUpdateTimesheets(xChronosheetsAuth: string, request: BatchUpdateTimesheetRequest, options?: any) {
        return TimesheetsApiFp(this.configuration).timesheetsUpdateTimesheets(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TranscriptsApi - axios parameter creator
 * @export
 */
export const TranscriptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an audio to text transcript for a particular audio file attachment
         * @param {number} fileAttachmentId The ID of the file attachment that has a transcript.  It should be an audio file attachment.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptsGetMyTranscript: async (fileAttachmentId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileAttachmentId' is not null or undefined
            if (fileAttachmentId === null || fileAttachmentId === undefined) {
                throw new RequiredError('fileAttachmentId','Required parameter fileAttachmentId was null or undefined when calling transcriptsGetMyTranscript.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling transcriptsGetMyTranscript.');
            }
            const localVarPath = `/Transcripts/GetMyTranscript`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileAttachmentId !== undefined) {
                localVarQueryParameter['FileAttachmentId'] = fileAttachmentId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my file transcripts.  Get audio to text transcripts that you\'ve created.
         * @param {string} startDate The Start date of the date range.  Transcripts after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Transcripts before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many transcripts
         * @param {number} [take] Take this many transcripts
         * @param {string} [keyword] Search the text content of the transcript keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptsGetMyTranscripts: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, keyword?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling transcriptsGetMyTranscripts.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling transcriptsGetMyTranscripts.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling transcriptsGetMyTranscripts.');
            }
            const localVarPath = `/Transcripts/GetMyTranscripts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['Keyword'] = keyword;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranscriptsApi - functional programming interface
 * @export
 */
export const TranscriptsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an audio to text transcript for a particular audio file attachment
         * @param {number} fileAttachmentId The ID of the file attachment that has a transcript.  It should be an audio file attachment.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptsGetMyTranscript(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTranscription>> {
            const localVarAxiosArgs = await TranscriptsApiAxiosParamCreator(configuration).transcriptsGetMyTranscript(fileAttachmentId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get my file transcripts.  Get audio to text transcripts that you\'ve created.
         * @param {string} startDate The Start date of the date range.  Transcripts after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Transcripts before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many transcripts
         * @param {number} [take] Take this many transcripts
         * @param {string} [keyword] Search the text content of the transcript keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptsGetMyTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, keyword?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListOrgReportTranscript>> {
            const localVarAxiosArgs = await TranscriptsApiAxiosParamCreator(configuration).transcriptsGetMyTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, keyword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TranscriptsApi - factory interface
 * @export
 */
export const TranscriptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get an audio to text transcript for a particular audio file attachment
         * @param {number} fileAttachmentId The ID of the file attachment that has a transcript.  It should be an audio file attachment.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptsGetMyTranscript(fileAttachmentId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseTranscription> {
            return TranscriptsApiFp(configuration).transcriptsGetMyTranscript(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my file transcripts.  Get audio to text transcripts that you\'ve created.
         * @param {string} startDate The Start date of the date range.  Transcripts after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Transcripts before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many transcripts
         * @param {number} [take] Take this many transcripts
         * @param {string} [keyword] Search the text content of the transcript keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptsGetMyTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, keyword?: string, options?: any): AxiosPromise<ApiResponseForPaginatedListOrgReportTranscript> {
            return TranscriptsApiFp(configuration).transcriptsGetMyTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, keyword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TranscriptsApi - object-oriented interface
 * @export
 * @class TranscriptsApi
 * @extends {BaseAPI}
 */
export class TranscriptsApi extends BaseAPI {
    /**
     * 
     * @summary Get an audio to text transcript for a particular audio file attachment
     * @param {number} fileAttachmentId The ID of the file attachment that has a transcript.  It should be an audio file attachment.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptsApi
     */
    public transcriptsGetMyTranscript(fileAttachmentId: number, xChronosheetsAuth: string, options?: any) {
        return TranscriptsApiFp(this.configuration).transcriptsGetMyTranscript(fileAttachmentId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my file transcripts.  Get audio to text transcripts that you\'ve created.
     * @param {string} startDate The Start date of the date range.  Transcripts after this date will be obtained.
     * @param {string} endDate The End date of the date range.  Transcripts before this date will be obtained.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many transcripts
     * @param {number} [take] Take this many transcripts
     * @param {string} [keyword] Search the text content of the transcript keywords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptsApi
     */
    public transcriptsGetMyTranscripts(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, keyword?: string, options?: any) {
        return TranscriptsApiFp(this.configuration).transcriptsGetMyTranscripts(startDate, endDate, xChronosheetsAuth, skip, take, keyword, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TripsApi - axios parameter creator
 * @export
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new trip.  Important: create a timesheet record before calling this, passing in the new timesheet record id as a reference.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateTripRequest} request A Create Trip Request object containing values for the new Trip to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCreateTrip: async (xChronosheetsAuth: string, request: CreateTripRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tripsCreateTrip.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling tripsCreateTrip.');
            }
            const localVarPath = `/Trips/CreateTrip`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trip by Id.    Requires the \'ViewMyTrips\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsGetMyTripById: async (tripId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            if (tripId === null || tripId === undefined) {
                throw new RequiredError('tripId','Required parameter tripId was null or undefined when calling tripsGetMyTripById.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tripsGetMyTripById.');
            }
            const localVarPath = `/Trips/GetMyTripById`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tripId !== undefined) {
                localVarQueryParameter['TripId'] = tripId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my trips.  Get the GPS trips you\'ve recorded and submitted.    Requires the \'ViewMyTrips\' permission.
         * @param {string} startDate The Start date of the date range.  Trips after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Trips before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many Trips
         * @param {number} [take] Take this many Trips
         * @param {number} [vehicleId] Filter by a particular Vehicle (get trips made with a particular vehicle), specified by VehicleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsGetMyTrips: async (startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, vehicleId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling tripsGetMyTrips.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling tripsGetMyTrips.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling tripsGetMyTrips.');
            }
            const localVarPath = `/Trips/GetMyTrips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (vehicleId !== undefined) {
                localVarQueryParameter['VehicleId'] = vehicleId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 * @export
 */
export const TripsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new trip.  Important: create a timesheet record before calling this, passing in the new timesheet record id as a reference.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateTripRequest} request A Create Trip Request object containing values for the new Trip to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsCreateTrip(xChronosheetsAuth: string, request: CreateTripRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await TripsApiAxiosParamCreator(configuration).tripsCreateTrip(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get trip by Id.    Requires the \'ViewMyTrips\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsGetMyTripById(tripId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTrip>> {
            const localVarAxiosArgs = await TripsApiAxiosParamCreator(configuration).tripsGetMyTripById(tripId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get my trips.  Get the GPS trips you\'ve recorded and submitted.    Requires the \'ViewMyTrips\' permission.
         * @param {string} startDate The Start date of the date range.  Trips after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Trips before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many Trips
         * @param {number} [take] Take this many Trips
         * @param {number} [vehicleId] Filter by a particular Vehicle (get trips made with a particular vehicle), specified by VehicleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsGetMyTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, vehicleId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseForPaginatedListTrip>> {
            const localVarAxiosArgs = await TripsApiAxiosParamCreator(configuration).tripsGetMyTrips(startDate, endDate, xChronosheetsAuth, skip, take, vehicleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TripsApi - factory interface
 * @export
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new trip.  Important: create a timesheet record before calling this, passing in the new timesheet record id as a reference.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {CreateTripRequest} request A Create Trip Request object containing values for the new Trip to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCreateTrip(xChronosheetsAuth: string, request: CreateTripRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return TripsApiFp(configuration).tripsCreateTrip(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trip by Id.    Requires the \'ViewMyTrips\' permission.
         * @param {number} tripId The ID of the Trip you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsGetMyTripById(tripId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseTrip> {
            return TripsApiFp(configuration).tripsGetMyTripById(tripId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my trips.  Get the GPS trips you\'ve recorded and submitted.    Requires the \'ViewMyTrips\' permission.
         * @param {string} startDate The Start date of the date range.  Trips after this date will be obtained.
         * @param {string} endDate The End date of the date range.  Trips before this date will be obtained.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {number} [skip] Skip this many Trips
         * @param {number} [take] Take this many Trips
         * @param {number} [vehicleId] Filter by a particular Vehicle (get trips made with a particular vehicle), specified by VehicleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsGetMyTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, vehicleId?: number, options?: any): AxiosPromise<ApiResponseForPaginatedListTrip> {
            return TripsApiFp(configuration).tripsGetMyTrips(startDate, endDate, xChronosheetsAuth, skip, take, vehicleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TripsApi - object-oriented interface
 * @export
 * @class TripsApi
 * @extends {BaseAPI}
 */
export class TripsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new trip.  Important: create a timesheet record before calling this, passing in the new timesheet record id as a reference.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {CreateTripRequest} request A Create Trip Request object containing values for the new Trip to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public tripsCreateTrip(xChronosheetsAuth: string, request: CreateTripRequest, options?: any) {
        return TripsApiFp(this.configuration).tripsCreateTrip(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trip by Id.    Requires the \'ViewMyTrips\' permission.
     * @param {number} tripId The ID of the Trip you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public tripsGetMyTripById(tripId: number, xChronosheetsAuth: string, options?: any) {
        return TripsApiFp(this.configuration).tripsGetMyTripById(tripId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my trips.  Get the GPS trips you\'ve recorded and submitted.    Requires the \'ViewMyTrips\' permission.
     * @param {string} startDate The Start date of the date range.  Trips after this date will be obtained.
     * @param {string} endDate The End date of the date range.  Trips before this date will be obtained.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {number} [skip] Skip this many Trips
     * @param {number} [take] Take this many Trips
     * @param {number} [vehicleId] Filter by a particular Vehicle (get trips made with a particular vehicle), specified by VehicleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public tripsGetMyTrips(startDate: string, endDate: string, xChronosheetsAuth: string, skip?: number, take?: number, vehicleId?: number, options?: any) {
        return TripsApiFp(this.configuration).tripsGetMyTrips(startDate, endDate, xChronosheetsAuth, skip, take, vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserJobFavouritesApi - axios parameter creator
 * @export
 */
export const UserJobFavouritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserJobFavouriteRequest} request An Insert UserJobFavourite Request object containing values for the new UserJobFavourite to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesCreateJobFavourite: async (xChronosheetsAuth: string, request: InsertUserJobFavouriteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userJobFavouritesCreateJobFavourite.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling userJobFavouritesCreateJobFavourite.');
            }
            const localVarPath = `/UserJobFavourites/CreateJobFavourite`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} jobId The ID of the Job for the Job Favourite you want to delete.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesDeleteJobFavourite: async (jobId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling userJobFavouritesDeleteJobFavourite.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userJobFavouritesDeleteJobFavourite.');
            }
            const localVarPath = `/UserJobFavourites/DeleteJobFavourite`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                localVarQueryParameter['JobId'] = jobId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get your job favourites.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesGetJobFavourites: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userJobFavouritesGetJobFavourites.');
            }
            const localVarPath = `/UserJobFavourites/GetJobFavourites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserJobFavouritesApi - functional programming interface
 * @export
 */
export const UserJobFavouritesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserJobFavouriteRequest} request An Insert UserJobFavourite Request object containing values for the new UserJobFavourite to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userJobFavouritesCreateJobFavourite(xChronosheetsAuth: string, request: InsertUserJobFavouriteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await UserJobFavouritesApiAxiosParamCreator(configuration).userJobFavouritesCreateJobFavourite(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} jobId The ID of the Job for the Job Favourite you want to delete.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userJobFavouritesDeleteJobFavourite(jobId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await UserJobFavouritesApiAxiosParamCreator(configuration).userJobFavouritesDeleteJobFavourite(jobId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get your job favourites.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userJobFavouritesGetJobFavourites(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListUserJobFavourite>> {
            const localVarAxiosArgs = await UserJobFavouritesApiAxiosParamCreator(configuration).userJobFavouritesGetJobFavourites(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserJobFavouritesApi - factory interface
 * @export
 */
export const UserJobFavouritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserJobFavouriteRequest} request An Insert UserJobFavourite Request object containing values for the new UserJobFavourite to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesCreateJobFavourite(xChronosheetsAuth: string, request: InsertUserJobFavouriteRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return UserJobFavouritesApiFp(configuration).userJobFavouritesCreateJobFavourite(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a job favourite.    Requires the \'SubmitTimesheets\' permission.
         * @param {number} jobId The ID of the Job for the Job Favourite you want to delete.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesDeleteJobFavourite(jobId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return UserJobFavouritesApiFp(configuration).userJobFavouritesDeleteJobFavourite(jobId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get your job favourites.    Requires the \'SubmitTimesheets\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userJobFavouritesGetJobFavourites(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListUserJobFavourite> {
            return UserJobFavouritesApiFp(configuration).userJobFavouritesGetJobFavourites(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserJobFavouritesApi - object-oriented interface
 * @export
 * @class UserJobFavouritesApi
 * @extends {BaseAPI}
 */
export class UserJobFavouritesApi extends BaseAPI {
    /**
     * 
     * @summary Create a job favourite.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertUserJobFavouriteRequest} request An Insert UserJobFavourite Request object containing values for the new UserJobFavourite to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserJobFavouritesApi
     */
    public userJobFavouritesCreateJobFavourite(xChronosheetsAuth: string, request: InsertUserJobFavouriteRequest, options?: any) {
        return UserJobFavouritesApiFp(this.configuration).userJobFavouritesCreateJobFavourite(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a job favourite.    Requires the \'SubmitTimesheets\' permission.
     * @param {number} jobId The ID of the Job for the Job Favourite you want to delete.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserJobFavouritesApi
     */
    public userJobFavouritesDeleteJobFavourite(jobId: number, xChronosheetsAuth: string, options?: any) {
        return UserJobFavouritesApiFp(this.configuration).userJobFavouritesDeleteJobFavourite(jobId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get your job favourites.    Requires the \'SubmitTimesheets\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserJobFavouritesApi
     */
    public userJobFavouritesGetJobFavourites(xChronosheetsAuth: string, options?: any) {
        return UserJobFavouritesApiFp(this.configuration).userJobFavouritesGetJobFavourites(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserPayRatesApi - axios parameter creator
 * @export
 */
export const UserPayRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new pay rate for a particular user, archiving the previous pay rate.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserHourlyRateRequest} request An Insert UserHourlyRate Request object containing values for the new UserHourlyRate to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPayRatesCreatePayRate: async (xChronosheetsAuth: string, request: InsertUserHourlyRateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userPayRatesCreatePayRate.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling userPayRatesCreatePayRate.');
            }
            const localVarPath = `/UserPayRates/CreatePayRate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection of pay rates for a particular user, specified by user id.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UserHourlyRate objects
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPayRatesGetPayRates: async (userId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling userPayRatesGetPayRates.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userPayRatesGetPayRates.');
            }
            const localVarPath = `/UserPayRates/GetPayRates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPayRatesApi - functional programming interface
 * @export
 */
export const UserPayRatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new pay rate for a particular user, archiving the previous pay rate.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserHourlyRateRequest} request An Insert UserHourlyRate Request object containing values for the new UserHourlyRate to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPayRatesCreatePayRate(xChronosheetsAuth: string, request: InsertUserHourlyRateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInt32>> {
            const localVarAxiosArgs = await UserPayRatesApiAxiosParamCreator(configuration).userPayRatesCreatePayRate(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a collection of pay rates for a particular user, specified by user id.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UserHourlyRate objects
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPayRatesGetPayRates(userId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListUserHourlyRate>> {
            const localVarAxiosArgs = await UserPayRatesApiAxiosParamCreator(configuration).userPayRatesGetPayRates(userId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserPayRatesApi - factory interface
 * @export
 */
export const UserPayRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new pay rate for a particular user, archiving the previous pay rate.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserHourlyRateRequest} request An Insert UserHourlyRate Request object containing values for the new UserHourlyRate to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPayRatesCreatePayRate(xChronosheetsAuth: string, request: InsertUserHourlyRateRequest, options?: any): AxiosPromise<ApiResponseInt32> {
            return UserPayRatesApiFp(configuration).userPayRatesCreatePayRate(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a collection of pay rates for a particular user, specified by user id.    Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UserHourlyRate objects
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPayRatesGetPayRates(userId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListUserHourlyRate> {
            return UserPayRatesApiFp(configuration).userPayRatesGetPayRates(userId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPayRatesApi - object-oriented interface
 * @export
 * @class UserPayRatesApi
 * @extends {BaseAPI}
 */
export class UserPayRatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new pay rate for a particular user, archiving the previous pay rate.    Requires the \'ManageOrganisationUsers\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertUserHourlyRateRequest} request An Insert UserHourlyRate Request object containing values for the new UserHourlyRate to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPayRatesApi
     */
    public userPayRatesCreatePayRate(xChronosheetsAuth: string, request: InsertUserHourlyRateRequest, options?: any) {
        return UserPayRatesApiFp(this.configuration).userPayRatesCreatePayRate(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a collection of pay rates for a particular user, specified by user id.    Requires the \'ManageOrganisationUsers\' permission.
     * @param {number} userId The ID of the User for which you want to get UserHourlyRate objects
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPayRatesApi
     */
    public userPayRatesGetPayRates(userId: number, xChronosheetsAuth: string, options?: any) {
        return UserPayRatesApiFp(this.configuration).userPayRatesGetPayRates(userId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login to your ChronoSheets account and obtain an Auth Token which you can use for other ChronoSheets API methods.    Does not require any special permissions.
         * @param {DoLoginRequest} request A request object containing your username/email and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileDoLogin: async (request: DoLoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling userProfileDoLogin.');
            }
            const localVarPath = `/UserProfile/DoLogin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout of your ChronoSheets account.  This method ends and deletes your active session.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileDoLogout: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userProfileDoLogout.');
            }
            const localVarPath = `/UserProfile/DoLogout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get your own profile.  Use this method to obtain detailed information about your ChronoSheets user profile.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileGetMyProfile: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userProfileGetMyProfile.');
            }
            const localVarPath = `/UserProfile/GetMyProfile`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Keep a session alive.  Use this method to keep a session active.  You could use this to \'ping\' ChronoSheets every \'x\' minutes to make sure your Auth Token will keep working.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileKeepSessionAlive: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userProfileKeepSessionAlive.');
            }
            const localVarPath = `/UserProfile/KeepSessionAlive`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update your own profile.  Use this method to update your profile information or update/change your password.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateMyProfileRequest} request An Update MyProfile Request object containing updated fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileUpdateMyProfile: async (xChronosheetsAuth: string, request: UpdateMyProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling userProfileUpdateMyProfile.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling userProfileUpdateMyProfile.');
            }
            const localVarPath = `/UserProfile/UpdateMyProfile`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login to your ChronoSheets account and obtain an Auth Token which you can use for other ChronoSheets API methods.    Does not require any special permissions.
         * @param {DoLoginRequest} request A request object containing your username/email and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileDoLogin(request: DoLoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDoLoginResponse>> {
            const localVarAxiosArgs = await UserProfileApiAxiosParamCreator(configuration).userProfileDoLogin(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Logout of your ChronoSheets account.  This method ends and deletes your active session.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileDoLogout(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await UserProfileApiAxiosParamCreator(configuration).userProfileDoLogout(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get your own profile.  Use this method to obtain detailed information about your ChronoSheets user profile.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileGetMyProfile(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUserProfile>> {
            const localVarAxiosArgs = await UserProfileApiAxiosParamCreator(configuration).userProfileGetMyProfile(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Keep a session alive.  Use this method to keep a session active.  You could use this to \'ping\' ChronoSheets every \'x\' minutes to make sure your Auth Token will keep working.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileKeepSessionAlive(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await UserProfileApiAxiosParamCreator(configuration).userProfileKeepSessionAlive(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update your own profile.  Use this method to update your profile information or update/change your password.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateMyProfileRequest} request An Update MyProfile Request object containing updated fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileUpdateMyProfile(xChronosheetsAuth: string, request: UpdateMyProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUpdateProfileResponse>> {
            const localVarAxiosArgs = await UserProfileApiAxiosParamCreator(configuration).userProfileUpdateMyProfile(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Login to your ChronoSheets account and obtain an Auth Token which you can use for other ChronoSheets API methods.    Does not require any special permissions.
         * @param {DoLoginRequest} request A request object containing your username/email and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileDoLogin(request: DoLoginRequest, options?: any): AxiosPromise<ApiResponseDoLoginResponse> {
            return UserProfileApiFp(configuration).userProfileDoLogin(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout of your ChronoSheets account.  This method ends and deletes your active session.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileDoLogout(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return UserProfileApiFp(configuration).userProfileDoLogout(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get your own profile.  Use this method to obtain detailed information about your ChronoSheets user profile.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileGetMyProfile(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseUserProfile> {
            return UserProfileApiFp(configuration).userProfileGetMyProfile(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Keep a session alive.  Use this method to keep a session active.  You could use this to \'ping\' ChronoSheets every \'x\' minutes to make sure your Auth Token will keep working.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileKeepSessionAlive(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseBoolean> {
            return UserProfileApiFp(configuration).userProfileKeepSessionAlive(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update your own profile.  Use this method to update your profile information or update/change your password.    Does not require any special permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateMyProfileRequest} request An Update MyProfile Request object containing updated fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileUpdateMyProfile(xChronosheetsAuth: string, request: UpdateMyProfileRequest, options?: any): AxiosPromise<ApiResponseUpdateProfileResponse> {
            return UserProfileApiFp(configuration).userProfileUpdateMyProfile(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * 
     * @summary Login to your ChronoSheets account and obtain an Auth Token which you can use for other ChronoSheets API methods.    Does not require any special permissions.
     * @param {DoLoginRequest} request A request object containing your username/email and password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public userProfileDoLogin(request: DoLoginRequest, options?: any) {
        return UserProfileApiFp(this.configuration).userProfileDoLogin(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout of your ChronoSheets account.  This method ends and deletes your active session.    Does not require any special permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public userProfileDoLogout(xChronosheetsAuth: string, options?: any) {
        return UserProfileApiFp(this.configuration).userProfileDoLogout(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get your own profile.  Use this method to obtain detailed information about your ChronoSheets user profile.    Does not require any special permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public userProfileGetMyProfile(xChronosheetsAuth: string, options?: any) {
        return UserProfileApiFp(this.configuration).userProfileGetMyProfile(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Keep a session alive.  Use this method to keep a session active.  You could use this to \'ping\' ChronoSheets every \'x\' minutes to make sure your Auth Token will keep working.    Does not require any special permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public userProfileKeepSessionAlive(xChronosheetsAuth: string, options?: any) {
        return UserProfileApiFp(this.configuration).userProfileKeepSessionAlive(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update your own profile.  Use this method to update your profile information or update/change your password.    Does not require any special permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateMyProfileRequest} request An Update MyProfile Request object containing updated fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public userProfileUpdateMyProfile(xChronosheetsAuth: string, request: UpdateMyProfileRequest, options?: any) {
        return UserProfileApiFp(this.configuration).userProfileUpdateMyProfile(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user account in your organisation.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserRequest} request An Insert User Request object containing values for the new User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateTimesheetUser: async (xChronosheetsAuth: string, request: InsertUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usersCreateTimesheetUser.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling usersCreateTimesheetUser.');
            }
            const localVarPath = `/Users/CreateTimesheetUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a particular user in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {number} userId The User ID of the UserForManagement you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetTimesheetUser: async (userId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersGetTimesheetUser.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usersGetTimesheetUser.');
            }
            const localVarPath = `/Users/GetTimesheetUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users accounts in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetTimesheetUsers: async (xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usersGetTimesheetUsers.');
            }
            const localVarPath = `/Users/GetTimesheetUsers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user account.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateUserRequest} request A Update User Request object containing updated fields.  Make sure to specify the User Id in the request object so that ChronoSheets knows which User to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateTimesheetUser: async (xChronosheetsAuth: string, request: UpdateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usersUpdateTimesheetUser.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling usersUpdateTimesheetUser.');
            }
            const localVarPath = `/Users/UpdateTimesheetUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user account in your organisation.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserRequest} request An Insert User Request object containing values for the new User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreateTimesheetUser(xChronosheetsAuth: string, request: InsertUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseInsertUserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersCreateTimesheetUser(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a particular user in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {number} userId The User ID of the UserForManagement you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetTimesheetUser(userId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUserForManagement>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersGetTimesheetUser(userId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get users accounts in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetTimesheetUsers(xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListUserForManagement>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersGetTimesheetUsers(xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a user account.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateUserRequest} request A Update User Request object containing updated fields.  Make sure to specify the User Id in the request object so that ChronoSheets knows which User to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdateTimesheetUser(xChronosheetsAuth: string, request: UpdateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUpdateUserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersUpdateTimesheetUser(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a user account in your organisation.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {InsertUserRequest} request An Insert User Request object containing values for the new User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateTimesheetUser(xChronosheetsAuth: string, request: InsertUserRequest, options?: any): AxiosPromise<ApiResponseInsertUserResponse> {
            return UsersApiFp(configuration).usersCreateTimesheetUser(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a particular user in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {number} userId The User ID of the UserForManagement you want to get
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetTimesheetUser(userId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseUserForManagement> {
            return UsersApiFp(configuration).usersGetTimesheetUser(userId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users accounts in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetTimesheetUsers(xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListUserForManagement> {
            return UsersApiFp(configuration).usersGetTimesheetUsers(xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user account.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {UpdateUserRequest} request A Update User Request object containing updated fields.  Make sure to specify the User Id in the request object so that ChronoSheets knows which User to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateTimesheetUser(xChronosheetsAuth: string, request: UpdateUserRequest, options?: any): AxiosPromise<ApiResponseUpdateUserResponse> {
            return UsersApiFp(configuration).usersUpdateTimesheetUser(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a user account in your organisation.  Requires the \'ManageOrganisationUsers\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {InsertUserRequest} request An Insert User Request object containing values for the new User to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreateTimesheetUser(xChronosheetsAuth: string, request: InsertUserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersCreateTimesheetUser(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a particular user in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
     * @param {number} userId The User ID of the UserForManagement you want to get
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetTimesheetUser(userId: number, xChronosheetsAuth: string, options?: any) {
        return UsersApiFp(this.configuration).usersGetTimesheetUser(userId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users accounts in your organisation.  Requires the \'ManageOrganisationUsers\' or \'ManageOrganisationGroups\' permissions.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetTimesheetUsers(xChronosheetsAuth: string, options?: any) {
        return UsersApiFp(this.configuration).usersGetTimesheetUsers(xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user account.  Requires the \'ManageOrganisationUsers\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {UpdateUserRequest} request A Update User Request object containing updated fields.  Make sure to specify the User Id in the request object so that ChronoSheets knows which User to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateTimesheetUser(xChronosheetsAuth: string, request: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUpdateTimesheetUser(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsualHoursApi - axios parameter creator
 * @export
 */
export const UsualHoursApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UsualHours for
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usualHoursGetUsualHours: async (userId: number, xChronosheetsAuth: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usualHoursGetUsualHours.');
            }
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usualHoursGetUsualHours.');
            }
            const localVarPath = `/UsualHours/GetUsualHours`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetUsualHoursRequest} request A Set UsualHours Request object containing updated data.  Make sure to specify the Day types in the request object so that ChronoSheets knows which Days to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usualHoursSetUsualHours: async (xChronosheetsAuth: string, request: SetUsualHoursRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChronosheetsAuth' is not null or undefined
            if (xChronosheetsAuth === null || xChronosheetsAuth === undefined) {
                throw new RequiredError('xChronosheetsAuth','Required parameter xChronosheetsAuth was null or undefined when calling usualHoursSetUsualHours.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling usualHoursSetUsualHours.');
            }
            const localVarPath = `/UsualHours/SetUsualHours`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChronosheetsAuth !== undefined && xChronosheetsAuth !== null) {
                localVarHeaderParameter['x-chronosheets-auth'] = String(xChronosheetsAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsualHoursApi - functional programming interface
 * @export
 */
export const UsualHoursApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UsualHours for
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usualHoursGetUsualHours(userId: number, xChronosheetsAuth: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListUsualHoursDay>> {
            const localVarAxiosArgs = await UsualHoursApiAxiosParamCreator(configuration).usualHoursGetUsualHours(userId, xChronosheetsAuth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetUsualHoursRequest} request A Set UsualHours Request object containing updated data.  Make sure to specify the Day types in the request object so that ChronoSheets knows which Days to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usualHoursSetUsualHours(xChronosheetsAuth: string, request: SetUsualHoursRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await UsualHoursApiAxiosParamCreator(configuration).usualHoursSetUsualHours(xChronosheetsAuth, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsualHoursApi - factory interface
 * @export
 */
export const UsualHoursApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {number} userId The ID of the User for which you want to get UsualHours for
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usualHoursGetUsualHours(userId: number, xChronosheetsAuth: string, options?: any): AxiosPromise<ApiResponseListUsualHoursDay> {
            return UsualHoursApiFp(configuration).usualHoursGetUsualHours(userId, xChronosheetsAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
         * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
         * @param {SetUsualHoursRequest} request A Set UsualHours Request object containing updated data.  Make sure to specify the Day types in the request object so that ChronoSheets knows which Days to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usualHoursSetUsualHours(xChronosheetsAuth: string, request: SetUsualHoursRequest, options?: any): AxiosPromise<ApiResponseBoolean> {
            return UsualHoursApiFp(configuration).usualHoursSetUsualHours(xChronosheetsAuth, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsualHoursApi - object-oriented interface
 * @export
 * @class UsualHoursApi
 * @extends {BaseAPI}
 */
export class UsualHoursApi extends BaseAPI {
    /**
     * 
     * @summary Get usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
     * @param {number} userId The ID of the User for which you want to get UsualHours for
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsualHoursApi
     */
    public usualHoursGetUsualHours(userId: number, xChronosheetsAuth: string, options?: any) {
        return UsualHoursApiFp(this.configuration).usualHoursGetUsualHours(userId, xChronosheetsAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set usual hours (rostered hours) for an employee.  Requires the \'ManageOrganisationUsers\' permission.
     * @param {string} xChronosheetsAuth The ChronoSheets Auth Token
     * @param {SetUsualHoursRequest} request A Set UsualHours Request object containing updated data.  Make sure to specify the Day types in the request object so that ChronoSheets knows which Days to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsualHoursApi
     */
    public usualHoursSetUsualHours(xChronosheetsAuth: string, request: SetUsualHoursRequest, options?: any) {
        return UsualHoursApiFp(this.configuration).usualHoursSetUsualHours(xChronosheetsAuth, request, options).then((request) => request(this.axios, this.basePath));
    }

}


